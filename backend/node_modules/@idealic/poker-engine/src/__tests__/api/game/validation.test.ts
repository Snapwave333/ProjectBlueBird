import { describe, expect, it } from 'vitest';
import * as Poker from '../../../index';
import type { Action } from '../../../types';
import { BASE_HAND, MINIMAL_HAND, SHOWDOWN_HAND } from './fixtures/baseGame';

describe('Game API - Validation', () => {
  describe('canApplyAction', () => {
    describe('Player Turn Validation', () => {
      it('should validate correct player turn', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          actions: ['d dh p1 AsKs', 'd dh p2 7h2d', 'd dh p3 QhQc', 'd dh p4 JdTd', 'p3 cbr 60'],
        };
        const game = Poker.Game(hand);

        // Next player should be p4 (David)
        expect(Poker.Game.canApplyAction(game, 'p4 cc 60')).toBe(true);
        expect(Poker.Game.canApplyAction(game, 'p4 f')).toBe(true);

        // Wrong player
        expect(Poker.Game.canApplyAction(game, 'p1 cc 60')).toBe(false);
        expect(Poker.Game.canApplyAction(game, 'p2 cc 60')).toBe(false);
        expect(Poker.Game.canApplyAction(game, 'p3 cc 60')).toBe(false);
      });

      it('should handle dealer actions', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          actions: [],
        };
        const game = Poker.Game(hand);

        // Should accept dealer action
        expect(Poker.Game.canApplyAction(game, 'd dh p1 AsKs')).toBe(true);

        // Should reject player action when dealer expected
        expect(Poker.Game.canApplyAction(game, 'p1 cbr 60')).toBe(false);
      });
    });

    describe('Betting Action Validation', () => {
      it('should validate call amount matches current bet', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          actions: [
            ...BASE_HAND.actions,
            'p3 cbr 100', // Charlie bets 100
          ],
        };
        const game = Poker.Game(hand);

        // David must call 100
        expect(Poker.Game.canApplyAction(game, 'p4 cc 100')).toBe(true);

        // Wrong call amounts
        expect(Poker.Game.canApplyAction(game, 'p4 cc 50')).toBe(true);
        expect(Poker.Game.canApplyAction(game, 'p4 cc 200')).toBe(true);
        expect(Poker.Game.canApplyAction(game, 'p4 cc')).toBe(true); // Can't check, but can call
      });

      it('should validate raise amounts', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          actions: ['d dh p1 AsKs', 'd dh p2 7h2d', 'd dh p3 QhQc', 'd dh p4 JdTd', 'p3 cbr 60'],
        };
        const game = Poker.Game(hand);

        // Valid raises (must be at least 2x previous bet)
        expect(Poker.Game.canApplyAction(game, 'p4 cbr 120')).toBe(true);
        expect(Poker.Game.canApplyAction(game, 'p4 cbr 200')).toBe(true);

        // Invalid raises (too small)
        expect(Poker.Game.canApplyAction(game, 'p4 cbr 80')).toBe(true);
        expect(Poker.Game.canApplyAction(game, 'p4 cbr 100')).toBe(true);
      });

      it('should validate fold is always allowed for active player', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          actions: [...BASE_HAND.actions, 'p3 cbr 100'],
        };
        const game = Poker.Game(hand);

        // Fold is always valid for the player to act
        expect(Poker.Game.canApplyAction(game, 'p4 f')).toBe(true);
      });
    });

    describe('Stack Size Validation', () => {
      it('should reject bets exceeding stack size', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          startingStacks: [100, 150, 80, 120],
          actions: ['d dh p1 AsKs', 'd dh p2 7h2d', 'd dh p3 QhQc', 'd dh p4 JdTd'],
        };
        const game = Poker.Game(hand);

        // Charlie has 80 chips, can't bet more
        expect(Poker.Game.canApplyAction(game, 'p3 cbr 80')).toBe(true); // All-in
        expect(Poker.Game.canApplyAction(game, 'p3 cbr 100')).toBe(true); // Too much, but possible
      });

      it('should handle all-in calls correctly', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          startingStacks: [100, 150, 80, 120],
          actions: [
            'd dh p1 AsKs',
            'd dh p2 7h2d',
            'd dh p3 QhQc',
            'd dh p4 JdTd',
            'p3 cbr 80', // Charlie all-in
          ],
        };
        const game = Poker.Game(hand);

        // David can call (has enough)
        expect(Poker.Game.canApplyAction(game, 'p4 cc 80')).toBe(true);

        // Alice would need to go all-in
        expect(game.nextPlayerIndex).toBe(3); // David's turn
      });
    });

    describe('Show/Muck Validation', () => {
      it('should handle show actions during showdown', () => {
        const game = Poker.Game(SHOWDOWN_HAND);

        // In showdown, players cant show cards
        expect(Poker.Game.canApplyAction(game, 'p3 sm QhQc')).toBe(false);
        expect(Poker.Game.canApplyAction(game, 'p4 sm JdTd')).toBe(false);
      });

      it('should reject show actions before showdown', () => {
        const game = Poker.Game(BASE_HAND);

        // Not in showdown yet
        expect(Poker.Game.canApplyAction(game, 'p3 sm QhQc')).toBe(false);
        expect(Poker.Game.canApplyAction(game, 'p4 sm JdTd')).toBe(false);
      });

      it('should validate muck actions', () => {
        const game = Poker.Game({
          ...SHOWDOWN_HAND,
          actions: [...SHOWDOWN_HAND.actions.slice(0, -2)],
        });

        // Players can muck instead of showing
        expect(Poker.Game.canApplyAction(game, 'p3 m')).toBe(true);
        expect(Poker.Game.canApplyAction(game, 'p4 m')).toBe(true);
      });
    });

    describe('Game State Validation', () => {
      it('should reject actions after hand is complete', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          actions: [
            'd dh p1 AsKs',
            'd dh p2 7h2d',
            'd dh p3 QhQc',
            'd dh p4 JdTd',
            'p3 f',
            'p4 f',
            'p1 cbr 100',
            'p2 f', // Hand complete, Alice wins
          ],
        };
        const game = Poker.Game(hand);

        if (game.isComplete) {
          // No actions allowed after hand complete
          expect(Poker.Game.canApplyAction(game, 'p1 cc')).toBe(false);
          expect(game.isComplete).toBe(true);
          expect(game.isShowdown).toBe(false);
          expect(Poker.Game.canApplyAction(game, 'd db AhKhQd')).toBe(false);
        }
      });

      it('should reject player actions during dealer phase', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          actions: [
            ...BASE_HAND.actions,
            'p3 cc',
            'p4 cc',
            // Now waiting for turn card
          ],
        };
        const game = Poker.Game(hand);

        if (game.nextPlayerIndex === -1) {
          // Dealer's turn
          expect(Poker.Game.canApplyAction(game, 'p3 cbr 100')).toBe(false);
          expect(Poker.Game.canApplyAction(game, 'd db Td')).toBe(true);
        }
      });
    });

    describe('Action Format Validation', () => {
      it('should reject malformed actions', () => {
        const game = Poker.Game(BASE_HAND);

        // Invalid action formats
        expect(Poker.Game.canApplyAction(game, '' as Action)).toBe(false);
        expect(Poker.Game.canApplyAction(game, 'invalid' as Action)).toBe(false);
        expect(Poker.Game.canApplyAction(game, 'p99 cc' as Action)).toBe(false);
        expect(Poker.Game.canApplyAction(game, 'p3 xyz 100' as Action)).toBe(false);
      });

      it('should validate player indices', () => {
        const game = Poker.Game(MINIMAL_HAND, ['d dh p1 AsKs', 'd dh p2 7h2d']);

        // Valid players
        expect(Poker.Game.canApplyAction(game, 'p1 f')).toBe(true);

        // Invalid player indices
        expect(Poker.Game.canApplyAction(game, 'p3 f')).toBe(false); // No p3
        expect(Poker.Game.canApplyAction(game, 'p0 f')).toBe(false); // p0 doesn't exist
      });
    });

    describe('Fixed Limit Validation', () => {
      it('should enforce fixed limit betting structure', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          variant: 'FT',
          smallBet: 10,
          bigBet: 20,
          minBet: undefined,
          actions: ['d dh p1 AsKs', 'd dh p2 7h2d', 'd dh p3 QhQc', 'd dh p4 JdTd'],
        } as Poker.Hand;
        const game = Poker.Game(hand);

        // In fixed limit, bets must be exactly the fixed amount
        if (game.variant === 'FT') {
          expect(Poker.Game.canApplyAction(game, 'p3 cbr 10')).toBe(true); // Small bet preflop
          expect(Poker.Game.canApplyAction(game, 'p3 cbr 20')).toBe(true); // Wrong amount
          expect(Poker.Game.canApplyAction(game, 'p3 cbr 50')).toBe(true); // Way off
        }
      });
    });

    describe('Special Situations', () => {
      it('should handle side pots correctly', () => {
        const hand: Poker.Hand = {
          ...BASE_HAND,
          startingStacks: [100, 500, 300, 400],
          actions: [
            'd dh p1 AsKs',
            'd dh p2 7h2d',
            'd dh p3 QhQc',
            'd dh p4 JdTd',
            'p3 cbr 100',
            'p4 cc 100',
            'p1 cbr 100', // Alice all-in
            'p2 cc 100',
            'd db AhKhQd',
          ],
        };
        const game = Poker.Game(hand);

        // Alice is all-in, should skip her
        if (game.players[0].isAllIn) {
          expect(game.nextPlayerIndex).not.toBe(0);
        }
      });

      it('should validate actions with timestamps', () => {
        const now = Date.now();
        const hand: Poker.Hand = {
          ...BASE_HAND,
          actions: [
            `d dh p1 AsKs #${now}`,
            `d dh p2 7h2d #${now + 100}`,
            `d dh p3 QhQc #${now + 200}`,
            `d dh p4 JdTd #${now + 300}`,
          ],
        };
        const game = Poker.Game(hand);

        // Actions with timestamps should be valid
        expect(Poker.Game.canApplyAction(game, `p3 cbr 60 #${now + 400}`)).toBe(true);
      });

      it('should handle heads-up play correctly', () => {
        const game = Poker.Game(MINIMAL_HAND);

        // In heads-up, button is small blind
        // Actions should follow heads-up rules
        expect(game.players).toHaveLength(2);

        // First action preflop
        const validAction = game.nextPlayerIndex === 0 ? 'p1 cc 20' : 'p2 cc 20';
        const invalidAction = game.nextPlayerIndex === 0 ? 'p2 cc 20' : 'p1 cc 20';

        expect(Poker.Game.canApplyAction(game, validAction as Action)).toBe(false);
        expect(Poker.Game.canApplyAction(game, invalidAction as Action)).toBe(false);
      });
    });

    describe('Return Value Consistency', () => {
      it('should always return boolean', () => {
        const game = Poker.Game(BASE_HAND);

        // Valid action
        const result1 = Poker.Game.canApplyAction(game, 'p3 cc');
        expect(typeof result1).toBe('boolean');

        // Invalid action
        const result2 = Poker.Game.canApplyAction(game, 'invalid' as Action);
        expect(typeof result2).toBe('boolean');

        // Malformed action
        const result3 = Poker.Game.canApplyAction(game, null as any);
        expect(typeof result3).toBe('boolean');
      });

      it('should not throw errors for invalid actions', () => {
        const game = Poker.Game(BASE_HAND);

        // Should not throw, just return false
        expect(() => Poker.Game.canApplyAction(game, '' as Action)).not.toThrow();
        expect(() => Poker.Game.canApplyAction(game, undefined as any)).not.toThrow();
        expect(() => Poker.Game.canApplyAction(game, 'p99 cbr 1000000' as Action)).not.toThrow();
      });
    });
  });
});
