import { describe, expect, it } from 'vitest';
import * as Poker from '../../../index';
import type { Action } from '../../../types';
import { BASE_HAND, MINIMAL_HAND } from './fixtures/baseGame';

describe('Game API - Edge Cases', () => {
  describe('Extreme Stack Sizes', () => {
    it('should handle zero starting stacks', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        startingStacks: [5, 1000, 0, 1000],
      };
      // game constructor should throw
      // because player with chips 0 or lower than big blind CAN'T act
      expect(() => Poker.Game(hand)).toThrow();
    });

    it('should handle negative starting stacks', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        startingStacks: [-5, -1000, 0, 1000],
      };
      // game constructor should throw
      // because player with chips negative CAN'T act
      expect(() => Poker.Game(hand)).toThrow();
    });

    it('should handle fractional stacks if allowed', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        startingStacks: [100.5, 200.25, 300.75, 400.1],
      };
      const game = Poker.Game(hand);

      expect(game.players[0].stack).toBe(90.5);
      expect(game.players[1].stack).toBe(180.25);
    });
  });

  describe('Player Count Extremes', () => {
    it('should handle single player', () => {
      const hand: Poker.Hand = {
        variant: 'NT',
        players: ['Lonely'],
        startingStacks: [1000],
        blindsOrStraddles: [0],
        minBet: 20,
        antes: [0],
        actions: [],
      };

      const game = Poker.Game(hand);
      expect(game.players).toHaveLength(1);
      // Game might be immediately complete or waiting
      expect(game.isComplete || game.nextPlayerIndex >= -1).toBe(true);
    });

    it('should handle maximum players (10)', () => {
      const hand: Poker.Hand = {
        variant: 'NT',
        players: ['P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9', 'P10'],
        startingStacks: [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000],
        blindsOrStraddles: [0, 0, 0, 0, 0, 0, 0, 0, 10, 20],
        antes: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        minBet: 20,
        actions: [],
      };

      const game = Poker.Game(hand);
      expect(game.players).toHaveLength(10);
    });
  });

  describe('Action Sequence Edge Cases', () => {
    it('should handle empty actions array', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [],
      };

      const game = Poker.Game(hand);
      expect(game).toBeDefined();
      expect(game.board).toEqual([]);
      expect(game.street).toBe('preflop');
    });

    it('should handle actions array with only dealer actions', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: ['d dh p1 AsKs', 'd dh p2 7h2d', 'd dh p3 QhQc', 'd dh p4 JdTd'],
      };

      const game = Poker.Game(hand);
      expect(game.players[0].cards).toEqual(['As', 'Ks']);
      expect(game.street).toBe('preflop');
      expect(game.nextPlayerIndex).toBeGreaterThanOrEqual(0);
    });

    it('should handle incomplete action sequences', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [
          'd dh p1 AsKs',
          'd dh p2 7h2d',
          // Missing p3 and p4 hole cards
          'p3 cbr 60',
        ],
      };

      // Should either handle gracefully or throw
      expect(() => Poker.Game(hand)).toBeDefined();
    });

    it('should handle duplicate actions', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [
          'd dh p1 AsKs',
          'd dh p1 AsKs', // Duplicate
          'd dh p2 7h2d',
        ],
      };

      // Should handle or reject duplicates
      const game = Poker.Game(hand);
      expect(game.players[0].cards).toEqual(['As', 'Ks']);
    });
  });

  describe('Blind Structure Edge Cases', () => {
    it('should handle no blinds, should throw', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        blindsOrStraddles: [0, 0, 0, 0],
      };

      // this game variant MUST have blinds
      expect(() => Poker.Game(hand)).toThrow();
    });

    it('should handle unusual blind positions, should throw', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        blindsOrStraddles: [0, 10, 0, 20], // Blinds not in typical positions
      };

      // this game variant MUST have blinds in typical positions
      expect(() => Poker.Game(hand)).toThrow();
    });
  });

  describe('Card Dealing Edge Cases', () => {
    it('should handle invalid card notations gracefully', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [
          'd dh p1 XxYy' as Action, // Invalid cards
        ],
      };
      let game: Poker.Game;
      // Should either handle gracefully or throw
      expect(() => (game = Poker.Game(hand))).not.toThrow();
      expect(game!.players[0].cards).toEqual(['Xx', 'Yy']);
    });

    it('should handle duplicate cards in deck', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [
          'd dh p1 AsKs',
          'd dh p2 AsKs', // Same cards as p1
        ],
      };
      let game: Poker.Game;
      // Do not check for duplicate cards, any cards is OK
      expect(() => (game = Poker.Game(hand))).not.toThrow();
      expect(game!.players[0].cards).toEqual(['As', 'Ks']);
      expect(game!.players[1].cards).toEqual(['As', 'Ks']);
    });

    it('should handle too many board cards, should throw', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [
          ...BASE_HAND.actions,
          'd db Td',
          'd db 9s',
          'd db 8h', // 6th card - invalid
        ],
      };

      // Should have max 5 board cards
      expect(() => Poker.Game(hand)).toThrow();
    });
  });

  describe('Timing Edge Cases', () => {
    it('should handle negative time limits', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        timeLimit: -30, // negative time limit is like no time limit
      };

      const game = Poker.Game(hand);
      expect(Poker.Game.getTimeLeft(game)).toBe(Infinity);
    });

    it('should handle zero time limit', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        timeLimit: 0,
      };

      const game = Poker.Game(hand);
      expect(Poker.Game.getTimeLeft(game)).toBe(Infinity);
    });

    it('should handle very large time limits', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        timeLimit: Number.MAX_SAFE_INTEGER,
      };

      const game = Poker.Game(hand);
      const timeLeft = Poker.Game.getTimeLeft(game);
      expect(timeLeft).toBeLessThanOrEqual(Number.MAX_SAFE_INTEGER * 1000);
    });

    it('should handle timestamps in the future', () => {
      const futureTime = Date.now() + 1000000;
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [`d dh p1 AsKs #${futureTime}`],
      };

      const game = Poker.Game(hand);
      expect(game.lastTimestamp).toBe(futureTime);
    });

    it('should handle very old timestamps', () => {
      const oldTime = 0; // Unix epoch
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [`d dh p1 AsKs #${oldTime}`],
      };
      const now = Date.now(); // invalid timestamp is being replaced with current time
      const game = Poker.Game(hand);
      expect(game.lastTimestamp).toBeGreaterThan(now - 1000);
      expect(game.lastTimestamp).toBeLessThan(now + 1000);
    });
  });

  describe('Special Characters in Player Names', () => {
    it('should handle unicode characters', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        players: ['Alice', 'ðŸŽ®Player', 'ä¸­æ–‡å', 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ'],
      };

      const game = Poker.Game(hand);
      expect(game.players[1].name).toBe('ðŸŽ®Player');
      expect(game.players[2].name).toBe('ä¸­æ–‡å');
      expect(Poker.Game.getPlayerIndex(game, 'ðŸŽ®Player')).toBe(1);
    });

    it('should handle empty player names', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        players: ['', 'Bob', 'Ch arlie', 'David'],
      };

      const game = Poker.Game(hand);
      expect(game.players[0].name).toBe('');
      expect(Poker.Game.getPlayerIndex(game, '')).toBe(0);
    });

    it('should handle very long player names', () => {
      const longName = 'A'.repeat(1000);
      const hand: Poker.Hand = {
        ...BASE_HAND,
        players: [longName, 'Bob', 'Charlie', 'David'],
      };

      const game = Poker.Game(hand);
      expect(game.players[0].name).toBe(longName);
      expect(Poker.Game.getPlayerIndex(game, longName)).toBe(0);
    });
  });

  describe('Rake Edge Cases', () => {
    it('should handle 100% rake', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        rakePercentage: 1.0,
      };

      const game = Poker.Game(hand);
      const finished = Poker.Game.finish(game, hand);

      if (finished.rake !== undefined) {
        // All pot goes to rake
        expect(finished.rake).toBeLessThanOrEqual(finished.totalPot || 0);
      }
    });

    it('should handle negative rake', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        rakePercentage: -0.1,
      };

      const game = Poker.Game(hand);
      const finished = Poker.Game.finish(game, hand);

      if (finished.rake !== undefined) {
        // Should treat as 0 or handle specially
        expect(finished.rake).toBeGreaterThanOrEqual(0);
      }
    });

    it('should handle fixed rake amount', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        rake: 5,
        rakePercentage: undefined,
      };

      const game = Poker.Game(hand);
      const finished = Poker.Game.finish(game, hand);

      if (finished.rake !== undefined) {
        expect(finished.rake).toBe(5);
      }
    });
  });

  describe('Action Validation Edge Cases', () => {
    it('should handle malformed action strings', () => {
      const game = Poker.Game(BASE_HAND);

      // Various malformed actions
      //expect(Poker.Game.canApplyAction(game, '' as Action)).toBe(false);
      //expect(Poker.Game.canApplyAction(game, '   ' as Action)).toBe(false);
      //expect(Poker.Game.canApplyAction(game, 'p' as Action)).toBe(false);
      expect(Poker.Game.canApplyAction(game, 'p3' as Action)).toBe(false);
      //expect(Poker.Game.canApplyAction(game, 'cbr 100' as Action)).toBe(false);
      //expect(Poker.Game.canApplyAction(game, '3 cbr 100' as Action)).toBe(false);
    });

    it('should handle out-of-range player indices', () => {
      const game = Poker.Game(BASE_HAND);

      expect(Poker.Game.canApplyAction(game, 'p0 cc' as Action)).toBe(false);
      expect(Poker.Game.canApplyAction(game, 'p5 cc' as Action)).toBe(false);
      expect(Poker.Game.canApplyAction(game, 'p-1 cc' as Action)).toBe(false);
      expect(Poker.Game.canApplyAction(game, 'p99 cc' as Action)).toBe(false);
    });

    it('should handle invalid action types', () => {
      const game = Poker.Game(BASE_HAND);

      expect(Poker.Game.canApplyAction(game, 'p3 xyz' as Action)).toBe(false);
      expect(Poker.Game.canApplyAction(game, 'p3 call' as Action)).toBe(false);
      expect(Poker.Game.canApplyAction(game, 'p3 raise 100' as Action)).toBe(false);
      expect(Poker.Game.canApplyAction(game, 'p3 CHECK' as Action)).toBe(false);
    });

    it('should handle invalid amounts', () => {
      const game = Poker.Game(BASE_HAND);

      expect(Poker.Game.canApplyAction(game, 'p3 cbr -100' as Action)).toBe(true);
      expect(Poker.Game.canApplyAction(game, 'p3 cbr 0' as Action)).toBe(true);
      expect(Poker.Game.canApplyAction(game, 'p3 cbr abc' as Action)).toBe(true);
      expect(Poker.Game.canApplyAction(game, 'p3 cbr Infinity' as Action)).toBe(true);
      expect(Poker.Game.canApplyAction(game, 'p3 cbr NaN' as Action)).toBe(true);
    });
  });

  describe('State Recovery Edge Cases', () => {
    it('should handle contradictory state', () => {
      const hand: Poker.Hand = {
        ...BASE_HAND,
        actions: [
          'd dh p1 AsKs',
          'd dh p2 7h2d',
          'p1 f', // Alice folds
          'p1 cbr 100', // Alice bets after folding - contradiction
        ] as Action[],
      };

      // Should handle or reject contradictory actions
      expect(() => Poker.Game(hand)).toBeDefined();
    });

    it('should handle actions after hand complete', () => {
      const hand: Poker.Hand = {
        ...MINIMAL_HAND,
        actions: [
          'd dh p1 AsKs',
          'd dh p2 7h2d',
          'p1 cbr 100',
          'p2 f', // Hand complete
          'p1 cc', // Action after complete
        ] as Action[],
      };

      // Should handle or ignore actions after completion
      expect(() => Poker.Game(hand)).toBeDefined();
    });
  });

  describe('Null and Undefined Handling', () => {
    it('should handle undefined optional fields', () => {
      const hand: Poker.Hand = {
        variant: 'NT',
        players: ['Alice', 'Bob'],
        startingStacks: [1000, 1000],
        antes: [0, 0],
        blindsOrStraddles: [10, 20],
        minBet: 20,
        actions: [],
        // All optional fields undefined
        seed: undefined,
        timeLimit: undefined,
        rake: undefined,
        rakePercentage: undefined,
        currency: undefined,
        author: undefined,
      };

      const game = Poker.Game(hand);
      expect(game).toBeDefined();
      expect(Poker.Game.getTimeLeft(game)).toBe(Infinity);
    });

    it('should handle null values gracefully', () => {
      const game = Poker.Game(BASE_HAND);

      // Various null/undefined inputs
      expect(Poker.Game.getPlayerIndex(game, null as any)).toBe(-1);
      expect(Poker.Game.getPlayerIndex(game, undefined as any)).toBe(-1);
      expect(Poker.Game.hasActed(game, null as any)).toBe(false);
      expect(Poker.Game.hasActed(game, undefined as any)).toBe(false);
      expect(Poker.Game.canApplyAction(game, null as any)).toBe(false);
      expect(Poker.Game.canApplyAction(game, undefined as any)).toBe(false);
    });
  });

  describe('Concurrent Modifications', () => {
    it('should handle rapid successive actions', () => {
      let game = Poker.Game(BASE_HAND);

      // Simulate rapid action application
      const actions: Action[] = ['p3 cc', 'p4 cc'];

      for (const action of actions) {
        if (Poker.Game.canApplyAction(game, action)) {
          game = Poker.Game.applyAction(game, action);
        }
      }

      expect(game).toBeDefined();
      expect(game.street).toBeDefined();
    });

    it('should maintain consistency across multiple operations', () => {
      const game = Poker.Game(BASE_HAND);

      // Multiple query operations shouldn't affect each other
      const index1 = Poker.Game.getPlayerIndex(game, 'Alice');
      const showdown1 = game.isShowdown;
      const hasActed1 = Poker.Game.hasActed(game, 'Charlie');

      const index2 = Poker.Game.getPlayerIndex(game, 'Alice');
      const showdown2 = game.isShowdown;
      const hasActed2 = Poker.Game.hasActed(game, 'Charlie');

      expect(index1).toBe(index2);
      expect(showdown1).toBe(showdown2);
      expect(hasActed1).toBe(hasActed2);
    });
  });
});
