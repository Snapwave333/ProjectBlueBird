/**
 * @instructions Actions should be applied to the table immediately after they are generated
 */

import { describe, expect } from 'vitest';
import { Game } from '../../Game';
import { bet, call, check, dealBoard, fold, raise } from '../../game/commands';
import { applyAction } from '../../game/progress';
import { canBet, canCall, canCheck, canFold, canRaise } from '../../game/validation';
import type { Hand } from '../../Hand';

const baseHand: Hand = {
  variant: 'NT',
  currency: 'USD',
  players: ['Hero', 'Villain', 'BB'],
  startingStacks: [1000, 1000, 1000],
  blindsOrStraddles: [0, 10, 20],
  antes: [],
  time: new Date().toISOString(),
  timeZone: 'UTC',
  minBet: 20,
  actions: ['d dh p1 AhKh', 'd dh p2 QhJh', 'd dh p3 ThTd'],
};

describe('Table State', () => {
  describe('canCheck', () => {
    it('allows BB to check after SB calls preflop', () => {
      const game = Game(baseHand);
      expect(canCall(game, 0)).toBe(true);
      applyAction(game, call(game, 0));

      // Big blind player should be able to check
      expect(game.players[2].totalBet).toBe(20); // BB player
      expect(game.players[2].hasActed).toBe(false);
      expect(game.players[2].hasFolded).toBe(false);
      expect(canCheck(game, 2)).toBe(true);

      // Verify check action works
      applyAction(game, check(game, 1));
      expect(game.players[1].hasActed).toBe(true);
      expect(game.players[1].totalBet).toBe(20);
    });

    it('prevents SB from checking when facing BB', () => {
      const game = Game(baseHand);

      // First player has only posted small blind
      expect(game.players[1].totalBet).toBe(10);
      expect(game.players[1].hasActed).toBe(false);
      expect(game.players[1].hasFolded).toBe(false);
      expect(canCheck(game, 1)).toBe(false);
    });
  });

  describe('canCall', () => {
    it('allows UTG to call BB preflop', () => {
      const game = Game(baseHand);

      // First player faces BB of 20 and has only posted 0
      expect(game.players[0].totalBet).toBe(0);
      expect(game.players[0].stack).toBe(1000);
      expect(game.players[0].hasActed).toBe(false);
      expect(game.players[0].hasFolded).toBe(false);
      expect(canCall(game, 0)).toBe(true);

      // Verify call action works
      applyAction(game, call(game, 0));
      expect(game.players[0].hasActed).toBe(true);
      expect(game.players[0].totalBet).toBe(20);
    });

    it('prevents BB from calling when no bets to call', () => {
      const game = Game(baseHand);
      applyAction(game, call(game, 0));

      // Player who posted BB should not be able to call
      expect(game.players[2].totalBet).toBe(20);
      expect(game.players[2].hasActed).toBe(false);
      expect(game.players[2].hasFolded).toBe(false);
      expect(canCall(game, 2)).toBe(false);
    });
  });

  describe('canBet', () => {
    it('allows first player to bet on flop', () => {
      // Complete preflop action
      const game = Game(baseHand);
      applyAction(game, call(game, 0));
      applyAction(game, call(game, 1));
      applyAction(game, check(game, 2));

      // Deal flop
      applyAction(game, dealBoard(game, ['Ac', 'Kc', 'Qc']));

      // First player should be able to bet on flop
      expect(game.players[0].hasActed).toBe(false);
      expect(game.players[0].hasFolded).toBe(false);
      expect(game.isComplete).toBe(false);
      expect(game.bet).toBe(0);
      expect(canBet(game, 0)).toBe(true);

      // Verify bet action works
      applyAction(game, bet(game, 1, 50));
      expect(game.players[1].hasActed).toBe(true);
      expect(game.players[1].totalBet).toBe(70); // 20 from preflop call + 50 from flop bet
      expect(game.bet).toBe(50);
    });

    it('prevents betting preflop when BB is posted', () => {
      const game = Game(baseHand);

      // Can't bet preflop because BB is posted
      expect(game.bet).toBe(20);
      expect(canBet(game, 0)).toBe(false);
    });
  });

  describe('canRaise', () => {
    it('allows UTG to raise over BB preflop', () => {
      const game = Game(baseHand);

      // First player can raise over BB
      expect(game.players[0].stack).toBe(1000);
      expect(game.bet).toBe(20);
      expect(game.players[0].hasActed).toBe(false);
      expect(game.players[0].hasFolded).toBe(false);
      expect(canRaise(game, 0)).toBe(true);

      // Verify raise action works
      applyAction(game, raise(game, 0, 60));
      expect(game.players[0].hasActed).toBe(true);
      expect(game.players[0].totalBet).toBe(60);
      expect(game.bet).toBe(60);
    });

    it('prevents raising on flop with no bets', () => {
      // Complete preflop action
      const game = Game(baseHand);
      applyAction(game, call(game, 0));
      applyAction(game, call(game, 1));
      applyAction(game, check(game, 2));

      // Deal flop
      applyAction(game, dealBoard(game, ['Ac', 'Kc', 'Qc']));

      // Can't raise on flop with no bets
      expect(game.bet).toBe(0);
      expect(canRaise(game, 0)).toBe(false);
    });

    it('prevents raising with insufficient stack', () => {
      const smallStackGame = {
        ...baseHand,
        startingStacks: [30, 1000, 1000],
      };
      const game = Game(smallStackGame);

      // First player can't raise over BB with only 30 chips
      expect(game.players[0].stack).toBe(30);
      expect(game.bet).toBe(20);
      expect(game.players[0].hasActed).toBe(false);
      expect(game.players[0].hasFolded).toBe(false);
      expect(canRaise(game, 0)).toBe(false);
    });
  });

  describe('canFold', () => {
    it('allows UTG to fold facing BB preflop', () => {
      const game = Game(baseHand);

      // First player can fold facing BB
      expect(game.players[0].totalBet).toBe(0);
      expect(game.bet).toBe(20);
      expect(game.players[0].hasActed).toBe(false);
      expect(game.players[0].hasFolded).toBe(false);
      expect(canFold(game, 0)).toBe(true);

      // Verify fold action works
      applyAction(game, fold(game, 0));
      expect(game.players[0].hasActed).toBe(true);
      expect(game.players[0].hasFolded).toBe(true);
    });

    it('prevents folding on flop with no bets', () => {
      // Complete preflop action
      const game = Game(baseHand);
      applyAction(game, call(game, 0));
      applyAction(game, call(game, 1));
      applyAction(game, check(game, 2));

      // Deal flop
      applyAction(game, dealBoard(game, ['Ac', 'Kc', 'Qc']));

      // Can't fold on flop with no bets
      expect(game.bet).toBe(0);
      expect(canFold(game, 0)).toBe(false);
    });
  });
});
