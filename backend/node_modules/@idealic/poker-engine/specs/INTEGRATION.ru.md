# План интеграции покера

Этот документ описывает план разработки и интеграции новой игры в покер, разделяя работу на три основных этапа.

---

## Архитектурная философия: Основа, не зависящая от игры

Ключевым принципом этой интеграции является создание общей, многократно используемой бэкенд-инфраструктуры, которая сможет поддерживать не только покер, но и будущие игры с минимальными дополнительными инженерными затратами.

- **Общие компоненты:** Основные механизмы бэкенда — `GameEngineLogs`, `GameEngineTables`, `BusinessSessions`, а также логика посадки за стол, тайм-аутов и продвижения состояния — намеренно спроектированы так, чтобы быть независимыми от конкретной игры. Они отвечают на вопрос «что» (состояние игры существует, сессия активна), но не «как» (конкретные правила игры).
- **Задел на будущее:** Такой подход означает, что интеграция новой игры в будущем (например, домино) в основном потребует создания нового модуля с логикой игрового движка и нового фронтенд-интерфейса. Сложная, фундаментальная работа по управлению сессиями, жизненным циклом столов и сохранению состояния уже будет выполнена и готова к повторному использованию.
- **Компоненты, специфичные для покера:** Единственные части этого плана, которые относятся исключительно к покеру:
  1.  Сам модуль логики `poker-engine`.
  2.  Фронтенд-компонент **Основной игровой UI**.
  3.  Схема таблицы `GameEnginePokerStats`, которая адаптирована под специфичные для покера метрики.

---

## Этап 0: Инфраструктура и DevOps

**Цель:** Создать надежную, контейнеризированную и наблюдаемую среду для поддержки разработки, тестирования и развертывания.
**Ответственный:** Алекс

### Предварительные условия (Ответственность команды Casino)

1.  **Рефакторинг платформы для масштабируемости (Ответственный: Михаил):**
    - **Действие:** Подготовить существующую платформу к контейнеризации и кластеризации.
    - **Логика:**
      - Выделить сокет-сервер в отдельный, готовый к контейнеризации сервис.
      - Провести рефакторинг бэкенда для удаления всех механизмов кеширования в рамках одного процесса, что обеспечит горизонтальное масштабирование без состояния.
2.  **Финализация Бизнес-сессии:**
    - **Действие:** Финализировать модель `BusinessSession` на основе предоставленной заглушки.
    - **Логика:** Определить триггеры начала/окончания сессии и интегрировать механику бай-инов.

### Задачи (Ответственность Алекса)

1.  **Полная контейнеризация проекта**
    - **Действие:** Создать Dockerfiles и конфигурацию Docker Compose для всего стека приложения.
    - **Область:** Включает бэкенд, фронтенд, сокет-сервер, тест-раннер и сервисы базы данных.

2.  **Улучшение CI/CD конвейера**
    - **Действие:** Обновить рабочий процесс GitHub Actions для запуска полного стека `docker-compose`.
    - **Цель:** Обеспечить выполнение интеграционных тестов в среде, максимально приближенной к производственной.

3.  **Инструментация и мониторинг бэкенда**
    - **Действие:** Интегрировать библиотеку инструментации (например, OpenTelemetry) во все сервисы Node.js.
    - **Цель:** Обеспечить наблюдаемость за производительностью приложения, запросами к базе данных и общим состоянием системы.

4.  **Кластеризация сервера Node.js**
    - **Действие:** Внедрить кластеризацию Node.js для основного бэкенд-сервиса.
    - **Цель:** Использовать несколько ядер ЦП для повышения пропускной способности и отказоустойчивости. (Зависит от рефакторинга платформы).

---

## Этап 1: Основной многопользовательский геймплей

**Цель:** Дать возможность реальным пользователям играть в полноценную многопользовательскую игру в покер.

### Бэкенд-разработка

1.  **Ядро логики продвижения игры**
    - **Действие:** Абстрагировать основную логику продвижения состояния игры в выделенный, многократно используемый компонент/функцию.
    - **Обязанности:** Этот компонент будет единственным источником истины для обработки любого игрового действия. Его обязанности включают:
      - Принятие состояния игры и действия игрока в качестве входных данных.
      - Использование покерного движка для проверки действия и вычисления следующего состояния.
      - Сохранение нового состояния в базу данных через `UPSERT`.
      - Расчет и сохранение тайм-аута для следующего игрока.
      - Инициирование отправки маскированных уведомлений о состоянии всем игрокам.

2.  **Endpoint управления состоянием игры**
    - **Действие:** Создать endpoint, который принимает действия игрока (например, ставка, чек, фолд).
    - **Логика:** Этот endpoint действует как тонкая обертка. Он получает нотацию действия игрока, загружает текущее состояние игры, а затем вызывает компонент **Ядро логики продвижения игры** для обработки действия.

3.  **Обработка тайм-аута игрока**
    - **Действие:** Внедрить фоновый процесс для обработки игроков, которые не действуют вовремя.
    - **Логика:**
      - Фоновый механизм опроса внутри процесса Node.js (например, с помощью `setInterval`) запускается каждую секунду для запроса в базе данных игр с истекшим тайм-аутом.
      - Для каждой игры с истекшим тайм-аутом система генерирует действие «авто-фолд» и вызывает компонент **Ядро логики продвижения игры** для его обработки.

4.  **Посадка за стол и управление столами**
    - **Действие:** Создать endpoint для присоединения игроков к игре.
    - **Логика:**
      - Игрок запрашивает присоединение к игре с определенным лимитом, опционально предоставляя конкретный `tableId`.
      - Система ищет стол, который соответствует критериям (лимит и опциональный `tableId`) и имеет свободные места. Свободное место определяется проверкой того, что количество активных `BusinessSessions`, связанных со столом, меньше его `max_seats`.
      - **Если подходящий стол найден:** Игрок садится за стол, и для него создается новая `BusinessSession`, связывающая его со столом. Он будет участвовать в раздаче со следующей руки.
      - **Если стол не найден (и `tableId` не был указан):** Создается новый стол, и игрок садится за него первым.
    - **Жизненный цикл стола:**
      - Столы являются постоянными записями в базе данных.
      - Когда стол становится пустым (или содержит только ботов) на определенный период (например, 15 минут), он помечается как «закрытый», а не удаляется.

5.  **Логика новой раздачи и распределение выигрышей**
    - **Действие:** Автоматизировать начало новой раздачи и обработать распределение выигрышей из завершенной раздачи.
    - **Логика:**
      - Когда покерный движок определяет, что раздача окончена, бэкенд уведомляет всех игроков о результате.
      - Затем транзакция базы данных атомарно перераспределяет выигрыши. **Примечание:** Точная реализация этой транзакции зависит от окончательного дизайна `BusinessSession` от команды Casino. Это может включать прямое обновление значения `stack` в активных сессиях или вызов отдельного, централизованного сервиса транзакций.
      - После короткой фиксированной задержки (например, 3 секунды) автоматически начинается новая раздача, и игроки получают уведомления.

### Фронтенд-разработка

1.  **UI выбора лимитов игры**
    - **Действие:** Адаптировать существующий UI выбора лимитов для покера.
    - **Логика:**
      - Создать новый, пользовательский шаблон UI для отображения покерных ставок (например, «1/2», «5/10») вместо общего формата лимитов.
      - Заполнить UI записями о покерных лимитах, созданными через миграцию базы данных.

2.  **Процесс бай-ина игрока**
    - **Действие:** Реализовать процесс бай-ина игрока, который управляется Бизнес-сессией.
    - **Логика:**
      - **Поведение по умолчанию:** Изначально, когда для покерной игры создается `BusinessSession`, игрок автоматически вносит в игру весь свой доступный баланс.
      - **Будущий UI:** Полноценный UI (например, модальное окно) для выбора произвольной суммы бай-ина будет реализован позже. Этот UI будет обновлять поле `buy_in` в `BusinessSession`.

3.  **Клиентский запрос на посадку**
    - **Действие:** Сразу после создания `BusinessSession` клиентская логика инициирует процесс посадки.
    - **Логика:** Клиент вызывает endpoint бэкенда «Посадка за стол и управление столами». Затем он ожидает успешного ответа, прежде чем пытаться отобразить игровой UI, чтобы убедиться, что игрок правильно посажен за стол.

4.  **Основной игровой UI**
    - **Ответственный:** Саргис.
    - **Действие:** Создать основной интерфейс покерного стола, где происходит игра.
    - **Архитектура:** UI будет действовать как слой представления для `poker-engine`. Он будет получать полное, маскированное состояние игры с сервера и отображать его. Его основные обязанности — это визуальное представление и сбор пользовательского ввода (например, клики по кнопкам «ставка» или «фолд») для отправки соответствующей нотации действия на бэкенд. Он не будет содержать сложной игровой логики, так как она полностью обрабатывается движком на стороне сервера.

### Управление сессиями

- **Действие:** Спроектировать и внедрить новую модель «Бизнес-сессии» для отслеживания длительной активности игроков.
- **Владение и финализация:** Модель `BusinessSession` была реализована в виде минимальной, не предписывающей заглушки для поддержки системы покерных столов. Окончательная реализация является ответственностью команды **Casino**. Мы просим вас взять эту заглушку за основу для дальнейшего расширения. Ключевые области для финализации включают определение точных триггеров начала/окончания сессии и интеграцию механики бай-инов. Заглушка была спроектирована таким образом, чтобы ее можно было полностью адаптировать к вашим окончательным архитектурным решениям.
- **Логика:**
  - Сессия начинается, когда игрок присоединяется к столу, и заканчивается, когда он его покидает.
  - Эта сессия будет отслеживать игрока, стол, за которым он находится (`table_id`), его `buy_in` и другие специфичные для игры метаданные в столбце `JSONB`.
  - Это критически важно для отслеживания активных игроков, управления вместимостью столов и расчета биллинга Jade.
  - **Примечание:** Это новая, отдельная концепция от существующей реализации сессий.

---

## Этап 2: Интеграция ботов

**Цель:** Позволить ботам играть против людей, чтобы столы всегда были активны.

1.  **API ботов и вебхуки**
    - **Действие:** Создать необходимый коммуникационный слой между основным бэкендом и сервисом ботов.
    - **Вебхук 1: Уведомление об изменении состояния игры:** Каждый раз, когда любой игрок (человек или бот) делает ход, отправлять новое состояние игры сервису ботов для всех ботов за этим столом.
    - **Вебхук 2: Запрос на присоединение бота к столу:** Когда человеку нужны оппоненты, отправлять запрос сервису ботов, чтобы один или несколько ботов присоединились к определенному столу.
    - **Endpoint для действий ботов:** Сервис ботов будет вызывать тот же endpoint обновления игры, который используют люди, для отправки своих ходов.

2.  **Аутентификация**
    - **Действие:** Внедрить безопасный метод аутентификации для сервиса ботов.
    - **Логика:** Endpoint обновления игры будет изменен для приема секретного API-ключа в заголовке запроса, обходя стандартную аутентификацию по сессии пользователя.

3.  **Профили пользователей-ботов**
    - **Действие:** Убедиться, что боты представлены в системе как обычные пользователи.
    - **Логика:**
      - Пул профилей пользователей-ботов (с именами и аватарами, сгенерированными ИИ) будет предварительно создан и сохранен в базе данных пользователей.
      - Когда бот присоединяется к игре, он ассоциируется с одним из этих профилей.
    - **Начальный скоуп:** В начальной реализации боты будут играть только в публичном Лобби, чтобы упростить логику, связанную с частными клубами.

---

## Этап 3: Статистика и аналитика

**Цель:** Сбор, хранение и агрегация подробной игровой статистики для будущего анализа и функций, видимых игрокам.

1.  **Сбор сырой статистики (Фаза 1)**
    - **Действие:** Сохранять всю статистику, генерируемую покерным движком.
    - **Логика:**
      - Создать новую таблицу в базе данных (`GameEnginePokerStats`).
      - При каждой раздаче сохранять в эту таблицу сырые JSON-данные статистики из движка.
    - **Цель:** Это гарантирует, что данные не будут потеряны, даже до внедрения продвинутой агрегации.

2.  **Агрегация данных с помощью TimescaleDB (Фаза 2)**
    - **Действие:** Интегрировать TimescaleDB для эффективной агрегации временных рядов.
    - **Логика:**
      - Обновить конфигурацию Docker проекта для использования образа TimescaleDB вместо стандартного PostgreSQL.
      - Создать одноразовый SQL-скрипт для инициализации функций TimescaleDB, включая создание гипертаблиц и непрерывных агрегатов для таблицы статистики.

3.  **UI статистики (Опциональная дополнительная цель)**
    - **Действие:** Создать виджет для отображения ключевой статистики игрокам.
    - **Зависит от:** Дизайна от Алексея. Это «приятное дополнение», которое можно отложить.

---

## Проектирование схемы базы данных

- **`GameEngineLogs`**: Хранит текущее состояние каждой активной игры. (Изменяемая)
  - `id`
  - `table_id` (Внешний ключ к `GameEngineTables`)
  - `limit_id` (ВК)
  - `club_id` (ВК)
  - `game_id` (ВК)
  - `hand` (JSONB) - Полное состояние игры от движка.
- **`GameEngineTables`**: Хранит метаданные о каждом покерном столе. (Постоянная)
  - `id`
  - `limit_id` (ВК)
  - `club_id` (ВК)
  - `game_id` (ВК)
  - `max_seats` (Integer)
  - `closed_at` (если закрыт)
- **`BusinessSessions`**: Новая, общая таблица для отслеживания длительных игровых сессий пользователей.
  - `id`
  - `user_id` (ВК)
  - `club_id` (ВК)
  - `game_id` (ВК)
  - `start_time`, `end_time`
  - `table_id` (ВК к `GameEngineTables`, nullable) - Конкретный стол, за которым находится игрок.
  - `stack` (Numeric) - Сумма, с которой игрок вошел в игру.
  - `settings` (JSONB) - Для любых других специфичных для игры динамических данных.
  - `jade_burn_rate_per_hour` (Numeric) - Количество джейдов, которое эта сессия потребляет в час. Этот тариф может отличаться для ботов и людей и может зависеть от уровня клуба.
- **`GameEnginePokerStats`**: Хранит сырую, неизменяемую статистику для каждой раздачи.
  - Будет определена структурой, предоставленной Ярославом.
