import request from 'supertest';
import { afterAll, afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import * as Engine from '../../../src';
import app, { timeoutPoller } from '../backend'; // The express app we want to test
import * as deps from '../backend.io';

afterAll(() => {
  clearInterval(timeoutPoller);
});

// Mock the entire dependencies module
vi.mock('../backend.dependencies', () => ({
  loadGameHand: vi.fn(),
  saveHand: vi.fn(),
  savePlayerStats: vi.fn(),
  broadcastToPlayers: vi.fn(),
  getSessionBalance: vi.fn(),
  updatePlayerBalance: vi.fn(),
  checkGameTimeouts: vi.fn(),
  authorizeRequest: vi.fn(),
}));

// ============================================================
// Fuzzy Testing Section
// ============================================================

// Mock database storage for fuzzy tests
const fuzzyDatabase = {
  games: new Map<string, Engine.Hand>(),
  playerBalances: new Map<string, number>(),
};

// State variables for fuzzy tests
let fuzzyCurrentHandId: string;
let fuzzyPreviousHandId: string;

function getFuzzyHandId(hand: Engine.Hand): string {
  if (!hand.venue || !hand.tableId || !hand.hand) {
    return hand.id || `unknown-hand-${Math.random()}`;
  }
  return `${hand.venue}-${hand.tableId}-${hand.hand}`;
}

describe.skip('Fuzzy testing - Random game scenarios', () => {
  // Async helper to replace the original synchronous processPokerRequest
  async function processRequest(hand: Engine.Hand): Promise<void> {
    const response = await request(app).post('/game/poker').send(hand);
    if (response.status !== 200) {
      console.error('Fuzzy test request failed:', response.status, response.body);
    }
  }

  beforeEach(() => {
    // Reset database and state for each fuzzy game
    fuzzyDatabase.games.clear();
    fuzzyDatabase.playerBalances.clear();
    fuzzyCurrentHandId = '';
    fuzzyPreviousHandId = '';

    // Set consistent time for testing
    vi.setSystemTime(new Date('2024-01-01T00:00:00Z'));

    // Setup mock implementations to use our in-memory database
    // @ts-ignore
    deps.loadGameHand.mockImplementation(
      (gameId: string) => fuzzyDatabase.games.get(gameId) || null
    );

    // @ts-ignore
    deps.saveHand.mockImplementation((hand: Engine.Hand) => {
      if (hand.id) {
        const handCopy = JSON.parse(JSON.stringify(hand));
        fuzzyDatabase.games.set(hand.id, handCopy);

        if (Engine.Hand.isComplete(handCopy)) {
          fuzzyPreviousHandId = handCopy.id;
        } else {
          // This is a new hand, so we update the currentHandId to follow the state change.
          fuzzyCurrentHandId = handCopy.id;
        }
      }
    });

    // @ts-ignore
    deps.savePlayerStats.mockImplementation(() => {}); // Not needed for this test's logic

    // @ts-ignore
    deps.updatePlayerBalance.mockImplementation((venueId: string, newBalance: number) => {
      // In the fuzzy test, venueId is the same as playerName
      fuzzyDatabase.playerBalances.set(venueId, newBalance);
    });

    // @ts-ignore
    deps.getSessionBalance.mockImplementation((playerName: string) => {
      return fuzzyDatabase.playerBalances.get(playerName) || 0;
    });
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  // Configuration for fuzzy tests
  interface FuzzyConfig {
    minGamesPerPlayerCount: number;
    seed?: number;
  }

  // Player statistics for one game
  interface PlayerGameStats {
    playerName: string;
    gameId: string;
    playerCount: number;
    gamesPlayed: number;
    totalWinnings: number;
    totalLosses: number;
    finalStack: number;
    startingStack: number;
  }

  // Logs for debugging
  interface GameLog {
    gameId: string;
    gameNumber: number;
    playerCount: number;
    seed: number;
    handsPlayed: number;
    outcome: 'completed' | 'error' | 'timeout';
    error?: string;
    endReason?: string;
  }

  // Seeded random number generator
  function createSeededRandom(seed: number) {
    let currentSeed = seed;
    return function () {
      currentSeed = (currentSeed * 1664525 + 1013904223) % 2147483648;
      return currentSeed / 2147483648;
    };
  }

  // Generate random table configuration
  function getRandomTableConfig(rng: () => number) {
    const minBet = Math.floor(rng() * 190) + 10; // 10-200
    return {
      minBet,
      seatCount: 9,
      seed: Math.floor(rng() * 1000000),
    };
  }

  // Generate random buy-in
  function getRandomBuyIn(rng: () => number, minBet: number) {
    const multiplier = Math.floor(rng() * 100) + 50; // 50-150 BB
    return minBet * multiplier;
  }

  // Determine if intent should be changed
  function shouldChangeIntent(rng: () => number): boolean {
    return rng() < 0.05; // 5% chance to change intent for more stable testing
  }

  // Generate random intent
  function getRandomIntent(rng: () => number): number {
    const roll = rng();
    if (roll < 0.85) return 0; // 85% - continue playing
    if (roll < 0.9) return 2; // 5% - pause
    if (roll < 0.95) return 3; // 5% - quit
    return 1; // 5% - wait for BB
  }

  // Determine if a new player should join
  function shouldPlayerJoin(
    rng: () => number,
    currentPlayerCount: number,
    maxSeats: number,
    handNumber: number
  ): boolean {
    if (currentPlayerCount >= maxSeats) return false;
    const baseChance = 0.05 - handNumber * 0.002;
    return rng() < Math.max(baseChance, 0.01); // Max 5% chance, at least 1%
  }

  // Determine if a player should leave
  function shouldPlayerLeave(
    rng: () => number,
    currentPlayerCount: number,
    handNumber: number
  ): boolean {
    if (currentPlayerCount <= 1) return false;
    const baseChance = 0.01 + handNumber * 0.001;
    return rng() < Math.min(baseChance, 0.05); // Max 5% chance
  }

  // Get active players
  function getActivePlayers(hand: Engine.Hand): string[] {
    return hand.players.filter((_, index) => {
      const isInactive = hand._inactive && hand._inactive[index];
      return !isInactive;
    });
  }

  // Check whose turn it is
  function isPlayerTurn(hand: Engine.Hand, playerName: string): boolean {
    if (Engine.Hand.isComplete(hand)) return false;
    try {
      const game = Engine.Game(hand);
      const currentPlayerIndex = game.nextPlayerIndex;
      if (currentPlayerIndex === undefined || currentPlayerIndex < 0) return false;
      const playerIndex = hand.players.indexOf(playerName);
      return playerIndex === currentPlayerIndex;
    } catch {
      return false;
    }
  }

  // Simulate player action (always check or call)
  async function simulatePlayerAction(hand: Engine.Hand, playerName: string): Promise<void> {
    const playerIndex = hand.players.indexOf(playerName);
    if (!isPlayerTurn(hand, playerName)) {
      return;
    }
    if (hand._inactive && hand._inactive[playerIndex]) {
      return;
    }

    const game = Engine.Game(hand);
    let action: string;
    const checkAction = Engine.Command.check(game, playerIndex);
    const callAction = Engine.Command.call(game, playerIndex);
    const foldAction = Engine.Command.fold(game, playerIndex);

    if (Engine.Game.canApplyAction(game, checkAction)) {
      action = checkAction;
    } else if (Engine.Game.canApplyAction(game, callAction)) {
      action = foldAction;
    } else {
      action = foldAction;
    }

    const updatedHand: Engine.Hand = {
      ...hand,
      author: playerName,
      actions: [...hand.actions, action],
    };

    await processRequest(updatedHand);
  }

  // Apply intent change
  async function applyIntentChange(
    hand: Engine.Hand,
    playerName: string,
    newIntent: number
  ): Promise<void> {
    let updatedHand: Engine.Hand;
    if (newIntent === 2) updatedHand = Engine.Hand.pause({ ...hand, author: playerName });
    else if (newIntent === 3) updatedHand = Engine.Hand.quit({ ...hand, author: playerName });
    else if (newIntent === 1) updatedHand = Engine.Hand.waitForBB({ ...hand, author: playerName });
    else updatedHand = Engine.Hand.resume({ ...hand, author: playerName });

    await processRequest(updatedHand);
  }

  it(
    'should handle random game scenarios with various player counts',
    { timeout: 120000 },
    async () => {
      let failSwitch = 0;
      const config: FuzzyConfig = {
        minGamesPerPlayerCount: 15,
        seed: Math.floor(Math.random() * 1000000),
      };
      console.log(`Fuzzy Test Seed: ${config.seed}`);

      const rng = createSeededRandom(config.seed!);
      const gameLogs: GameLog[] = [];
      let totalGamesPlayed = 0;

      for (let playerCount = 2; playerCount <= 9; playerCount++) {
        for (let gameNum = 0; gameNum < config.minGamesPerPlayerCount; gameNum++) {
          totalGamesPlayed++;
          const gameId = `fuzzy-game-${playerCount}-${gameNum}`;
          const gameSeed = Math.floor(rng() * 1000000);

          const gameLog: GameLog = {
            gameId,
            gameNumber: totalGamesPlayed,
            playerCount,
            seed: gameSeed,
            handsPlayed: 0,
            outcome: 'completed',
          };

          let serverState: Engine.Hand | undefined;
          try {
            fuzzyDatabase.games.clear();
            fuzzyDatabase.playerBalances.clear();
            fuzzyCurrentHandId = '';
            fuzzyPreviousHandId = '';

            const tableConfig = getRandomTableConfig(rng);
            let initialState: Engine.Hand = {
              variant: 'NT',
              players: [],
              startingStacks: [],
              blindsOrStraddles: [],
              antes: [],
              minBet: tableConfig.minBet,
              seatCount: tableConfig.seatCount,
              tableId: `table-${gameId}`,
              hand: 1,
              venue: 'venue-fuzzy',
              id: `venue-fuzzy-table-${gameId}-1`,
              actions: [],
              seed: tableConfig.seed,
              _inactive: [],
              _intents: [],
              _deadBlinds: [],
            };

            // Manually save and set currentHandId for the very first hand
            fuzzyDatabase.games.set(initialState.id!, initialState);
            fuzzyCurrentHandId = initialState.id!;

            const playerNames: string[] = [];
            let nextPlayerNumber = 0;
            for (let i = 0; i < playerCount; i++) {
              const playerName = `Player_${nextPlayerNumber++}`;
              playerNames.push(playerName);
              const buyIn = getRandomBuyIn(rng, tableConfig.minBet);
              const initialBalance = buyIn * 3;
              fuzzyDatabase.playerBalances.set(playerName, initialBalance);

              const joinHand = Engine.Hand.join(fuzzyDatabase.games.get(fuzzyCurrentHandId)!, {
                playerName,
                buyIn,
              });
              await processRequest(joinHand);
            }

            serverState = fuzzyDatabase.games.get(fuzzyCurrentHandId)!;

            let handCount = 0;
            const maxHands = 20;
            let totalActions = 0;
            const maxTotalActions = 1000;

            while (handCount < maxHands && totalActions < maxTotalActions) {
              const currentHandNumber = serverState.hand || 0;
              let actionCount = 0;
              const maxActionsPerHand = 50;

              if (
                shouldPlayerJoin(rng, serverState.players.length, tableConfig.seatCount, handCount)
              ) {
                const newPlayerName = `Player_${nextPlayerNumber++}`;
                const buyIn = getRandomBuyIn(rng, tableConfig.minBet);
                fuzzyDatabase.playerBalances.set(newPlayerName, buyIn * 3);
                const joinHand = Engine.Hand.join(serverState, {
                  playerName: newPlayerName,
                  buyIn,
                });
                await processRequest(joinHand);
                serverState = fuzzyDatabase.games.get(fuzzyCurrentHandId)!;
              }

              if (
                shouldPlayerLeave(rng, serverState.players.length, handCount) &&
                serverState.players.length > 1
              ) {
                const activePlayerIndices = serverState.players
                  .map((_, index) => index)
                  .filter(index => !serverState!._inactive || !serverState!._inactive[index]);
                if (activePlayerIndices.length > 0) {
                  const randomIndex =
                    activePlayerIndices[Math.floor(rng() * activePlayerIndices.length)];
                  const leavingPlayer = serverState.players[randomIndex];
                  const quitHand = Engine.Hand.quit({ ...serverState, author: leavingPlayer });
                  await processRequest(quitHand);
                  serverState = fuzzyDatabase.games.get(fuzzyCurrentHandId)!;
                }
              }

              const loopStartTime = Date.now();
              const maxLoopTime = 5000;

              while (actionCount < maxActionsPerHand && totalActions < maxTotalActions) {
                if (Date.now() - loopStartTime > maxLoopTime) {
                  console.log(`[${gameId}] DEBUG: Loop time exceeded.`);
                  gameLog.outcome = 'timeout';
                  break;
                }

                actionCount++;
                totalActions++;

                const prevHandId = fuzzyCurrentHandId;
                const prevActionCount = serverState.actions.length;

                let currentPlayerIndex: number | undefined;
                try {
                  currentPlayerIndex = Engine.Game(serverState).nextPlayerIndex;
                } catch (e) {
                  currentPlayerIndex = undefined;
                }

                if (Engine.Hand.isComplete(serverState)) {
                  console.log(`[${gameId}] [HAND COMPLETE] State before processing:`, {
                    id: serverState.id,
                    hand: serverState.hand,
                    actions: serverState.actions.length,
                    isComplete: Engine.Hand.isComplete(serverState),
                  });
                  await processRequest(serverState);
                  serverState = fuzzyDatabase.games.get(fuzzyCurrentHandId)!;
                  console.log(`[${gameId}] [HAND COMPLETE] State after processing:`, {
                    id: serverState?.id,
                    hand: serverState?.hand,
                    actions: serverState?.actions.length,
                    isComplete: serverState ? Engine.Hand.isComplete(serverState) : 'undefined',
                  });
                } else if (currentPlayerIndex === undefined || currentPlayerIndex < 0) {
                  await processRequest(serverState);
                  serverState = fuzzyDatabase.games.get(fuzzyCurrentHandId)!;
                  console.log(`[${gameId}] [STATE AFTER GET] No current player`, {
                    id: serverState?.id,
                  });
                } else {
                  const currentPlayer = serverState.players[currentPlayerIndex];
                  if (shouldChangeIntent(rng)) {
                    const newIntent = getRandomIntent(rng);
                    await applyIntentChange(serverState, currentPlayer, newIntent);
                    serverState = fuzzyDatabase.games.get(fuzzyCurrentHandId)!;
                    continue;
                  }
                  if (!serverState._inactive?.[serverState.players.indexOf(currentPlayer)]) {
                    await simulatePlayerAction(serverState, currentPlayer);
                    serverState = fuzzyDatabase.games.get(fuzzyCurrentHandId)!;
                  }
                }
                if (fuzzyCurrentHandId !== prevHandId) {
                  handCount++;
                  gameLog.handsPlayed = handCount;
                  break;
                }

                if (
                  serverState.actions.length === prevActionCount &&
                  !Engine.Hand.isComplete(serverState)
                ) {
                  if (getActivePlayers(serverState).length < 2) {
                    gameLog.endReason = 'not_enough_players';
                    break;
                  }
                  console.log(`[${gameId}] [TIMEOUT CONDITION] No action processed.`, {
                    serverState: JSON.stringify(serverState, null, 2),
                  });
                  gameLog.outcome = 'timeout';
                  break;
                }
              }
              if (gameLog.outcome === 'timeout' || gameLog.endReason) {
                break;
              }
            }
            if (totalActions >= maxTotalActions) {
              gameLog.outcome = 'timeout';
            }
            gameLogs.push(gameLog);
          } catch (error) {
            gameLog.outcome = 'error';
            gameLog.error = error instanceof Error ? error.message : String(error);
            gameLogs.push(gameLog);
            console.error(`[${gameId}] ERROR during game execution:`, error);
          }
        }
      }

      const errorLogs = gameLogs.filter(log => log.outcome === 'error');
      const timeoutLogs = gameLogs.filter(log => log.outcome === 'timeout');

      if (errorLogs.length > 0) {
        console.error('Fuzzy Test Errors:', JSON.stringify(errorLogs, null, 2));
      }
      if (timeoutLogs.length > 0) {
        console.warn('Fuzzy Test Timeouts:', JSON.stringify(timeoutLogs, null, 2));
      }

      expect(errorLogs, 'Fuzzy test should have no errors').toHaveLength(0);
      expect(timeoutLogs, 'Fuzzy test should have no timeouts').toHaveLength(0);
    }
  );
});
