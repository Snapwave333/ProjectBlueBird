import request from 'supertest';
import { afterAll, afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import * as Engine from '../../../src';
import { getActionType } from '../../../src/game/position';
import app, { timeoutPoller } from '../backend.express'; // The express app we want to test
import * as deps from '../backend.io';

afterAll(() => {
  clearInterval(timeoutPoller);
});

// Mock the entire dependencies module
vi.mock('../backend.io', () => ({
  loadGameHand: vi.fn(),
  saveHand: vi.fn(),
  savePlayerStats: vi.fn(),
  broadcastToPlayers: vi.fn(),
  getSessionBalance: vi.fn(),
  updatePlayerBalance: vi.fn(),
  checkGameTimeouts: vi.fn(),
  authorizeRequest: vi.fn(),
}));

// ============================================================
// Ported Integration Tests from src/__tests__/api/integration
// ============================================================

describe('Backend Integration - Full Game Lifecycle', () => {
  // Mock database storage
  const database = {
    games: new Map<string, Engine.Hand>(),
    playerBalances: new Map<string, number>(),
    playerStats: new Map<string, any[]>(),
  };

  // State variables
  let currentHandId: string;
  let previousHandId: string;

  function getHandKey(hand: Engine.Hand): string {
    if (!hand.venue || !hand.hand) {
      return `unknown-hand-${Math.random()}`;
    }
    return `${hand.venue}-${hand.hand}`;
  }

  // Async helper to send requests to the app
  async function processRequest(hand: Engine.Hand): Promise<void> {
    console.log(
      `[processRequest] Sending hand: ${getHandKey(hand)}, author: ${hand.author}, actions: ${hand.actions?.length}`
    );
    const response = await request(app).post('/game/poker').send(hand);
    if (response.status !== 200 && response.status !== 404) {
      // 404 is acceptable if the hand is old and already processed/removed
      console.error('Test request failed:', response.status, response.body);
    }
    console.log(`[processRequest] Completed for hand: ${getHandKey(hand)}`);
  }

  beforeEach(() => {
    // Reset database and state
    database.games.clear();
    database.playerBalances.clear();
    database.playerStats.clear();
    currentHandId = '';
    previousHandId = '';

    // Set consistent time for testing
    vi.setSystemTime(new Date('2024-01-01T00:00:00Z'));

    // Setup mock implementations to use our in-memory database
    // @ts-ignore
    deps.loadGameHand.mockImplementation((venue: string, id: string) => {
      const hand = database.games.get(`${venue}-${id}`);
      //console.log(`[loadGameHand] Loading game: ${gameId}. Found: ${!!hand}`);
      // Return a deep copy to prevent tests from modifying the "database" object directly
      return hand ? JSON.parse(JSON.stringify(hand)) : null;
    });

    // @ts-ignore
    deps.saveHand.mockImplementation((hand: Engine.Hand) => {
      const handCopy = JSON.parse(JSON.stringify(hand));
      const handId = getHandKey(handCopy);

      console.log('[saveHand] mock:', {
        handId,
        isComplete: Engine.Hand.isComplete(handCopy),
        handNumber: handCopy.hand,
        previousHandId,
        currentHandId,
      });

      // Step 1: Always save the current state to the "database".
      database.games.set(handId, handCopy);

      // Step 2: Update pointers based on the state.
      if (Engine.Hand.isComplete(handCopy)) {
        // This hand is now history.
        previousHandId = handId;
        console.log(`[saveHand] Hand ${handId} is complete. Set previousHandId.`);
      } else {
        // This hand is the current active hand.
        currentHandId = handId;
        console.log(`[saveHand] Hand ${handId} is active. Set currentHandId.`);
      }
    });

    // @ts-ignore
    deps.savePlayerStats.mockImplementation((hand: Engine.Hand) => {});

    // @ts-ignore
    deps.updatePlayerBalance.mockImplementation(
      (playerName: string, venueId: string, newBalance: number) => {
        // In tests, venueId is often the same as playerName
        database.playerBalances.set(venueId, newBalance);
      }
    );

    // @ts-ignore
    deps.getSessionBalance.mockImplementation((playerName: string) => {
      const updatedBalance = database.playerBalances.get(playerName);
      if (updatedBalance !== undefined) {
        return updatedBalance;
      }
      const initialBalances: Record<string, number> = {
        dddocky: 10000,
        'Duke Croix': 10000,
        HighCardJasper: 10000,
        Player_A: 1000,
        Player_B: 1000,
      };
      return initialBalances[playerName] || 10000;
    });

    // @ts-ignore
    deps.broadcastToPlayers.mockImplementation(() => {});
    // @ts-ignore
    deps.authorizeRequest.mockImplementation(() => {});
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('Complete game lifecycle from empty table to showdown', () => {
    it(
      'should handle players joining empty table, playing a full hand, and transitioning to next hand',
      { timeout: 30000 },
      async () => {
        // SCENARIO: Replay a fixture-like hand from empty table through completion.
        // Two players join and start playing. A third player joins and waits for the next hand.
        // Players play the game to the end. Then a new game with three players starts.

        console.log('--- Test Start ---');

        // Step 1: Create empty table
        let serverState: Engine.Hand = {
          variant: 'NT',
          players: [],
          startingStacks: [],
          blindsOrStraddles: [],
          antes: [],
          minBet: 100,
          seatCount: 9,
          table: 'table-1',
          actions: [],
          seed: 12345,
          hand: 1,
          venue: 'venue-1',
          _inactive: [],
          _intents: [],
          _deadBlinds: [],
        };
        database.games.set(getHandKey(serverState), serverState);
        currentHandId = getHandKey(serverState);
        console.log(`[Step 1] Initial state created. currentHandId: ${currentHandId}`);

        // Step 2: dddocky joins
        const dddockyJoins = Engine.Hand.join(serverState, {
          playerName: 'dddocky',
          buyIn: 10000,
        });
        await processRequest(dddockyJoins);
        serverState = database.games.get(currentHandId)!;
        console.log(`[Step 2] dddocky joined. Players: ${serverState.players.length}`);

        expect(serverState.players).toEqual(['dddocky']);
        expect(serverState._inactive).toEqual([2]); // New player starts inactive
        expect(serverState._intents).toEqual([0]);

        // Step 3: Duke Croix joins
        const dukeJoins = Engine.Hand.join(serverState, {
          playerName: 'Duke Croix',
          buyIn: 10000,
        });
        await processRequest(dukeJoins);
        serverState = database.games.get(currentHandId)!;
        console.log(
          `[Step 3] Duke Croix joined. Players: ${serverState.players.length}. Game should start.`
        );

        expect(serverState.players).toEqual(['dddocky', 'Duke Croix']);
        expect(serverState._inactive).toEqual([0, 0]); // Both players active, game starts
        expect(serverState._intents).toEqual([0, 0]);

        // Step 4: HighCardJasper joins
        const jasperJoins = Engine.Hand.join(serverState, {
          playerName: 'HighCardJasper',
          buyIn: 10000,
        });
        await processRequest(jasperJoins);
        serverState = database.games.get(currentHandId)!;
        console.log(`[Step 4] HighCardJasper joined. Players: ${serverState.players.length}.`);

        expect(serverState.players).toEqual(['dddocky', 'Duke Croix', 'HighCardJasper']);
        expect(serverState._inactive).toEqual([0, 0, 2]);
        expect(serverState.startingStacks).toEqual([10000, 10000, 10000]);

        // Step 5: Game has started automatically after Duke joined.
        // Verify cards were dealt to the first two players
        const dealActions = serverState.actions.filter(a => getActionType(a) === Engine.DEAL_HAND);
        expect(dealActions.length).toBe(2);
        console.log('[Step 5] Verified initial deal.');

        // Step 6: Simulate player actions
        // dddocky calls BB
        console.log('[Step 6.1] dddocky calls.');
        const dddockyCall: Engine.Hand = {
          ...serverState,
          author: 'dddocky',
          actions: [
            ...serverState.actions,
            Engine.Command.call(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'dddocky')
            ),
          ],
        };
        await processRequest(dddockyCall);
        serverState = database.games.get(currentHandId)!;

        // Duke Croix checks
        console.log('[Step 6.2] Duke Croix checks.');
        const dukeCheck: Engine.Hand = {
          ...serverState,
          author: 'Duke Croix',
          actions: [
            ...serverState.actions,
            Engine.Command.check(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'Duke Croix')
            ),
          ],
        };
        await processRequest(dukeCheck);
        serverState = database.games.get(currentHandId)!;

        // Flop should be dealt
        expect(getActionType(serverState.actions.at(-1))).toBe(Engine.DEAL_BOARD);
        console.log('[Step 6.3] Verified flop was dealt.');

        // ... continue with flop, turn, river actions ...
        console.log('[Step 6.4] Duke Croix checks flop.');
        const dukeCheckFlop = {
          ...serverState,
          author: 'Duke Croix',
          actions: [
            ...serverState.actions,
            Engine.Command.check(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'Duke Croix')
            ),
          ],
        };
        await processRequest(dukeCheckFlop);
        serverState = database.games.get(currentHandId)!;

        console.log('[Step 6.5] dddocky bets on flop.');
        const dddockyBetFlop = {
          ...serverState,
          author: 'dddocky',
          actions: [
            ...serverState.actions,
            Engine.Command.bet(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'dddocky'),
              100
            ),
          ],
        };
        await processRequest(dddockyBetFlop);
        serverState = database.games.get(currentHandId)!;

        console.log('[Step 6.6] Duke Croix raises on flop.');
        const dukeRaiseFlop = {
          ...serverState,
          author: 'Duke Croix',
          actions: [
            ...serverState.actions,
            Engine.Command.raise(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'Duke Croix'),
              200
            ),
          ],
        };
        await processRequest(dukeRaiseFlop);
        serverState = database.games.get(currentHandId)!;

        console.log('[Step 6.7] dddocky calls on flop.');
        const dddockyCallFlop = {
          ...serverState,
          author: 'dddocky',
          actions: [
            ...serverState.actions,
            Engine.Command.call(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'dddocky')
            ),
          ],
        };
        await processRequest(dddockyCallFlop);
        serverState = database.games.get(currentHandId)!;

        expect(getActionType(serverState.actions.at(-1))).toBe(Engine.DEAL_BOARD); // Turn
        console.log('[Step 6.8] Verified turn was dealt.');

        console.log('[Step 6.9] Duke Croix checks turn.');
        const dukeCheckTurn = {
          ...serverState,
          author: 'Duke Croix',
          actions: [
            ...serverState.actions,
            Engine.Command.check(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'Duke Croix')
            ),
          ],
        };
        await processRequest(dukeCheckTurn);
        serverState = database.games.get(currentHandId)!;

        console.log('[Step 6.10] dddocky bets on turn.');
        const dddockyBetTurn = {
          ...serverState,
          author: 'dddocky',
          actions: [
            ...serverState.actions,
            Engine.Command.bet(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'dddocky'),
              100
            ),
          ],
        };
        await processRequest(dddockyBetTurn);
        serverState = database.games.get(currentHandId)!;

        console.log('[Step 6.11] Duke Croix calls on turn.');
        const dukeCallTurn = {
          ...serverState,
          author: 'Duke Croix',
          actions: [
            ...serverState.actions,
            Engine.Command.call(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'Duke Croix')
            ),
          ],
        };
        await processRequest(dukeCallTurn);
        serverState = database.games.get(currentHandId)!;

        expect(getActionType(serverState.actions.at(-1))).toBe(Engine.DEAL_BOARD); // River
        console.log('[Step 6.12] Verified river was dealt.');

        console.log('[Step 6.13] Duke Croix checks river.');
        const dukeCheckRiver = {
          ...serverState,
          author: 'Duke Croix',
          actions: [
            ...serverState.actions,
            Engine.Command.check(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'Duke Croix')
            ),
          ],
        };
        await processRequest(dukeCheckRiver);
        serverState = database.games.get(currentHandId)!;

        console.log('[Step 6.14] dddocky bets on river.');
        const dddockyBetRiver = {
          ...serverState,
          author: 'dddocky',
          actions: [
            ...serverState.actions,
            Engine.Command.bet(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'dddocky'),
              100
            ),
          ],
        };
        await processRequest(dddockyBetRiver);
        serverState = database.games.get(currentHandId)!;

        // Duke's final call triggers showdown and hand completion
        console.log('[Step 6.15] Duke Croix makes final call on river.');
        const dukeCallRiver = {
          ...serverState,
          author: 'Duke Croix',
          actions: [
            ...serverState.actions,
            Engine.Command.call(
              Engine.Game(serverState),
              Engine.Hand.getPlayerIndex(serverState, 'Duke Croix')
            ),
          ],
        };
        await processRequest(dukeCallRiver);
        console.log(
          `[Step 6.16] Final action processed. currentHandId: ${currentHandId}, previousHandId: ${previousHandId}`
        );

        // Step 7: Verify hand is complete
        console.log('[Step 7] Verifying hand completion.');
        expect(previousHandId).toBeDefined();
        const finalServerState = database.games.get(previousHandId)!;
        expect(Engine.Hand.isComplete(finalServerState)).toBe(true);
        expect(finalServerState.finishingStacks).toBeDefined();
        expect(finalServerState.winnings).toBeDefined();
        console.log('[Step 7] Hand verified as complete.');

        // Step 8: Transition to next hand
        console.log('[Step 8] Verifying transition to next hand.');
        serverState = database.games.get(currentHandId)!;
        expect(serverState).toBeDefined();
        expect(serverState.hand).toBe(2);
        expect(serverState.players).toEqual(['dddocky', 'Duke Croix', 'HighCardJasper']);
        expect(serverState._inactive).toEqual([0, 0, 0]); // All 3 players active

        // Verify cards were dealt to all 3 players
        const nextDealActions = serverState.actions.filter(
          a => getActionType(a) === Engine.DEAL_HAND
        );
        expect(nextDealActions.length).toBe(3);
        console.log('[Step 8] Verified next hand started correctly. --- Test End ---');
      }
    );

    it('should handle sit-in and sit-out scenarios correctly', async () => {
      // Step 1: Create empty table
      let serverState: Engine.Hand = {
        variant: 'NT',
        players: [],
        startingStacks: [],
        blindsOrStraddles: [],
        antes: [],
        minBet: 100,
        seatCount: 9,
        table: 'table-2',
        actions: [],
        seed: 54321,
        hand: 1,
        venue: 'venue-1',
        _inactive: [],
        _intents: [],
        _deadBlinds: [],
      };
      database.games.set(getHandKey(serverState), serverState);
      currentHandId = getHandKey(serverState);

      // Step 2: Two players join, game starts
      await processRequest(Engine.Hand.join(serverState, { playerName: 'dddocky', buyIn: 10000 }));
      serverState = database.games.get(currentHandId)!;
      await processRequest(
        Engine.Hand.join(serverState, { playerName: 'Duke Croix', buyIn: 10000 })
      );
      serverState = database.games.get(currentHandId)!;

      expect(serverState.players).toEqual(['dddocky', 'Duke Croix']);
      expect(serverState._inactive).toEqual([0, 0]);
      expect(serverState.actions.length).toBeGreaterThan(0); // Cards dealt

      // Step 3: HighCardJasper joins mid-game
      await processRequest(
        Engine.Hand.join(serverState, { playerName: 'HighCardJasper', buyIn: 10000 })
      );
      serverState = database.games.get(currentHandId)!;
      expect(serverState.players).toEqual(['dddocky', 'Duke Croix', 'HighCardJasper']);
      expect(serverState._inactive).toEqual([0, 0, 2]); // Jasper is inactive

      // Step 4: Duke decides to sit out (pause)
      const dukeSitsOut = Engine.Hand.pause({ ...serverState, author: 'Duke Croix' });
      await processRequest(dukeSitsOut);

      // When Duke sits out, the hand should not complete automatically based on the current logic.
      // Instead, we verify that Duke is marked as sitting out and the hand continues.
      serverState = database.games.get(currentHandId)!; // This is the *same* hand

      // Verify the hand is not complete and is still the same hand
      expect(Engine.Hand.isComplete(serverState)).toBe(false);
      expect(serverState.hand).toBe(1);

      // Verify Duke's state has been updated to "paused"
      const dukeIndex = serverState.players.indexOf('Duke Croix');
      expect(serverState._intents![dukeIndex]).toBe(2); // 2 = paused
      expect(serverState._inactive![dukeIndex]).toBe(0); // 1 = sitting out this hand

      // Verify other players' states are unchanged
      const dddockyIndex = serverState.players.indexOf('dddocky');
      const jasperIndex = serverState.players.indexOf('HighCardJasper');
      expect(serverState._inactive![dddockyIndex]).toBe(0); // dddocky is still active
      expect(serverState._inactive![jasperIndex]).toBe(2); // Jasper is still waiting for the next hand
    });

    it('should handle all players leaving and edge cases', async () => {
      // Step 1: Setup a game with 3 players
      let serverState: Engine.Hand = {
        variant: 'NT',
        players: ['dddocky', 'Duke Croix', 'HighCardJasper'],
        startingStacks: [10000, 10000, 10000],
        blindsOrStraddles: [50, 100, 0],
        antes: [],
        minBet: 100,
        seatCount: 9,
        table: 'table-3',
        actions: [],
        seed: 123,
        hand: 1,
        venue: 'venue-1',
        _inactive: [0, 0, 0],
        _intents: [0, 0, 0],
        _deadBlinds: [0, 0, 0],
      };
      database.games.set(getHandKey(serverState), serverState);
      await processRequest(serverState); // Process to deal cards
      serverState = database.games.get(currentHandId)!;

      // Step 2: Player 1 (dddocky) leaves
      const dddockyLeaves = Engine.Hand.quit(serverState, 0);
      await processRequest(dddockyLeaves);
      serverState = database.games.get(currentHandId)!;
      expect(serverState._intents).toEqual([3, 0, 0]);

      // Step 3: Player 2 (Duke Croix) also leaves
      const dukeLeaves = Engine.Hand.quit({ ...serverState, author: 'Duke Croix' });
      await processRequest(dukeLeaves);

      // This leaves only one player, so hand completes.
      const completedHand = database.games.get(previousHandId)!;
      serverState = database.games.get(currentHandId)!; // New hand

      // Verify completed hand
      expect(Engine.Hand.isComplete(completedHand)).toBe(true);
      const jasperIndex = completedHand.players.indexOf('HighCardJasper');
      expect(completedHand.winnings![jasperIndex]).toBeGreaterThan(0);

      // Verify the new hand state (only Jasper left)
      expect(serverState.hand).toBe(2);
      expect(serverState.players).toEqual(['HighCardJasper']);
      expect(serverState._inactive).toEqual([0]);

      // Step 4: The last player (HighCardJasper) leaves
      const jasperLeaves = Engine.Hand.quit({ ...serverState, author: 'HighCardJasper' });
      await processRequest(jasperLeaves);

      const finalCompletedHand = database.games.get(previousHandId)!;
      const finalServerState = database.games.get(currentHandId)!;

      expect(Engine.Hand.isComplete(finalCompletedHand)).toBe(true);

      // The hand should not advance, as there are no players to start a new one.
      // The table is now empty, but the state reflects the last hand played.
      expect(finalServerState.hand).toBe(2);
      expect(finalServerState.players).toEqual(['HighCardJasper']);
      const lastPlayerIndex = finalServerState.players.indexOf('HighCardJasper');
      expect(finalServerState._intents![lastPlayerIndex]).toBe(3);
    });
  });

  describe('Player intent changes and state validation', () => {
    it('should automatically complete hand when player quits mid-game leaving only one player', async () => {
      // Step 1: Setup 2-player game and deal cards
      let serverState: Engine.Hand = {
        variant: 'NT',
        players: ['Player_A', 'Player_B'],
        startingStacks: [1000, 1000],
        blindsOrStraddles: [50, 100],
        antes: [],
        minBet: 100,
        table: 'table-quit-test',
        actions: [],
        seed: 99999,
        hand: 1,
        venue: 'venue-1',
        _inactive: [0, 0],
        _intents: [0, 0],
        _deadBlinds: [0, 0],
      };
      database.games.set(getHandKey(serverState), serverState);
      await processRequest(serverState);
      serverState = database.games.get(currentHandId)!;

      // Step 2: Player_B decides to quit
      const playerBQuits = Engine.Hand.quit({ ...serverState, author: 'Player_B' });
      await processRequest(playerBQuits);

      // Hand should complete
      const completedHand = database.games.get(previousHandId)!;
      expect(Engine.Hand.isComplete(completedHand)).toBe(true);
      const playerAIndex = completedHand.players.indexOf('Player_A');
      expect(completedHand.winnings![playerAIndex]).toBeGreaterThan(0);

      // Step 3: Verify new hand was created with only Player_A
      const newHand = database.games.get(currentHandId)!;
      expect(newHand.hand).toBe(2);
      expect(newHand.players).toEqual(['Player_A']);
    });

    it('should correctly handle wait-for-BB intent', async () => {
      // Step 1: Setup with dddocky on BTN waiting for BB
      let serverState: Engine.Hand = {
        variant: 'NT',
        players: ['dddocky', 'Duke Croix', 'HighCardJasper'],
        startingStacks: [10000, 10000, 10000],
        blindsOrStraddles: [0, 50, 100], // dddocky=BTN, Duke=SB, Jasper=BB
        antes: [],
        minBet: 100,
        table: 'table-3',
        actions: [],
        seed: 12345,
        hand: 1,
        venue: 'venue-1',
        _inactive: [1, 0, 0], // dddocky is sitting out
        _intents: [1, 0, 0], // dddocky waiting for BB
        _deadBlinds: [0, 0, 0],
      };
      database.games.set(getHandKey(serverState), serverState);
      await processRequest(serverState);
      serverState = database.games.get(currentHandId)!;

      // Verify dddocky is sitting out
      expect(serverState._inactive).toEqual([1, 0, 0]);
      const dealActions = serverState.actions.filter(a => getActionType(a) === Engine.DEAL_HAND);
      expect(dealActions.length).toBe(2);

      // Step 2: Play out the hand to completion (e.g., everyone folds to last bet)
      const dukeCall = {
        ...serverState,
        author: 'Duke Croix',
        actions: [
          ...serverState.actions,
          Engine.Command.call(
            Engine.Game(serverState),
            Engine.Hand.getPlayerIndex(serverState, 'Duke Croix')
          ),
        ],
      };
      await processRequest(dukeCall);
      serverState = database.games.get(currentHandId)!;

      const jasperFolds = {
        ...serverState,
        author: 'HighCardJasper',
        actions: [
          ...serverState.actions,
          Engine.Command.fold(
            Engine.Game(serverState),
            Engine.Hand.getPlayerIndex(serverState, 'HighCardJasper')
          ),
        ],
      };
      await processRequest(jasperFolds);

      // Hand is complete, new hand is created
      const newHand = database.games.get(currentHandId)!;

      // Step 3: Verify dddocky is now active in the new hand (as they are BB)
      expect(newHand.hand).toBe(2);
      expect(newHand._inactive).toEqual([0, 0, 0]);
      expect(newHand._intents).toEqual([0, 0, 0]);
      const dddockyIndex = newHand.players.indexOf('dddocky');
      expect(newHand.blindsOrStraddles[dddockyIndex]).toBe(100); // dddocky is BB
    });
  });
});
