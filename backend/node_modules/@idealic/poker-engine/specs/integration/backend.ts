import * as Engine from '@idealic/poker-engine';

import * as IO from './backend.io';

let io: typeof IO = IO;
/**
 * Set the IO implementation to use
 * @param io - The IO implementation to use
 */
export function setIO(io: typeof IO) {
  io = io;
}

/**
 * Validates and adjusts a new hand based on player session balances
 * Reads balances from sessions, validates stacks, and writes updates to DB
 * @param newHand - The new hand about to start
 * @param oldHand - The previous completed hand (undefined for first hand)
 * @returns Modified hand with validated stacks and removed players
 */
export function start(newHand: Engine.Hand, oldHand?: Engine.Hand): Engine.Hand {
  // Step 1: If there's a completed old hand, update player balances in DB
  if (oldHand && Engine.Hand.isComplete(oldHand)) {
    oldHand.players.forEach((playerName, index) => {
      const venueId = Engine.Hand.getPlayerId(oldHand, playerName) || playerName;

      // Calculate actual profit/loss (can be negative)
      const startingStack = oldHand.startingStacks[index];
      const finishingStack = oldHand.finishingStacks![index];
      const profitLoss = finishingStack - startingStack;

      // Get current balance from session
      const currentBalance = io.getSessionBalance(playerName);

      // Calculate new balance (using actual profit/loss)
      const newBalance = Math.max(0, currentBalance + profitLoss);

      // Write the new balance to database
      io.updatePlayerBalance(playerName, venueId, newBalance);
    });
  }

  // Step 2: Validate new hand stacks against session balances and remove broke players
  let resultHand = newHand;
  const validatedStacks = [...newHand.startingStacks];

  newHand.players.forEach((playerName, index) => {
    // Read the player's current balance from their session
    const sessionBalance = io.getSessionBalance(playerName);
    const requestedStack = newHand.startingStacks[index];

    // Validate the stack doesn't exceed their session balance
    if (requestedStack > sessionBalance) {
      if (sessionBalance > 0) {
        // Cap at their session balance
        validatedStacks[index] = sessionBalance;
        console.log(`Capped ${playerName}'s stack from ${requestedStack} to ${sessionBalance}`);
      } else {
        // No balance, mark player for removal using quitHand
        resultHand = Engine.Hand.quit(resultHand, index);
        console.log(`Marked ${playerName} for removal - no balance in session`);
      }
    }
  });

  // Return hand with validated stacks
  return {
    ...resultHand,
    startingStacks: validatedStacks,
  };
}

export function advance(hand: Engine.Hand): Engine.Hand {
  let resultHand = hand;
  let previousFinishedHand: Engine.Hand | undefined;

  // Keep advancing until the hand is stable (no more automatic actions)
  while (true) {
    const handBeforeAdvance = resultHand;
    const handAfterAdvance = Engine.Hand.advance(handBeforeAdvance);
    resultHand = handAfterAdvance;

    // Save the current hand state after any advancement
    io.saveHand(resultHand);
    io.savePlayerStats(resultHand);
    io.broadcastToPlayers(resultHand);

    // Check for completion first
    if (Engine.Hand.isComplete(resultHand)) {
      resultHand = Engine.Hand.finish(resultHand);
      previousFinishedHand = resultHand;

      let nextHand = Engine.Hand.next(resultHand);
      nextHand = start(nextHand, previousFinishedHand);
      resultHand = nextHand;

      // The loop must continue to process the new hand (e.g., deal cards)
      // The next iteration will save the new hand's state.
      continue;
    }

    // If the hand is not complete, check if it's stable.
    if (Engine.Hand.isEqual(handBeforeAdvance, handAfterAdvance)) {
      // Hand is stable and waiting for player action.
      break;
    }
    // Otherwise, the loop continues as more dealer actions may be needed.
  }

  // Save the final state of the hand after all advancements.
  io.saveHand(resultHand);
  io.savePlayerStats(resultHand);
  io.broadcastToPlayers(resultHand);

  return resultHand;
}

/**
 * Single endpoint for poker game state management
 * Follows the stateless request-response pattern described in the spec
 *
 * This endpoint demonstrates the complete server-side flow for managing poker hands:
 * 1. Receives hand state from client
 * 2. Merges with server state
 * 3. Advances the game (dealer actions)
 * 4. Handles hand completion and transitions
 * 5. Returns personalized state to client
 */
export function process(incomingHand: Engine.Hand): void {
  // ============================================================
  // STEP 1: Load authoritative server hand from database
  // ============================================================
  // The server maintains the authoritative game state
  let serverHand = io.loadGameHand(incomingHand.venue!, incomingHand.hand!);

  // ============================================================
  // STEP 2: Merge client actions with server state
  // ============================================================
  // Hand.merge intelligently combines the client's new actions with the server's state
  // This handles conflicts and ensures consistency
  if (serverHand) {
    serverHand = Engine.Hand.merge(serverHand, incomingHand);
  } else {
    // If no server hand exists, the incoming hand is the source of truth.
    // This typically happens on the very first action of a new game.
    serverHand = incomingHand;
  }

  // ============================================================
  // STEP 3: Advance the hand
  // ============================================================
  // advanceHand handles everything:
  // - Runs all necessary dealer actions
  // - Deals cards when needed
  // - Moves to next street (Folds\Mucks players who have timed out)
  // - Handles timeouts
  // - Manages showdown
  // - Finishes the hand when it's complete
  // - Automatically starts a new hand when the current hand is complete
  // - Writes the hand to database
  // - Writes player stats to database
  // - Broadcasts the hand to all players
  advance(serverHand);
}
