import * as Engine from '../../src';

// ============================================================
// Database Operations (Stubs)
// ============================================================

export function loadGameHand(venue: string, id: number): Engine.Hand | null {
  // TODO: Load the Hand from database by gameId
  // The 'log' JSONB field contains the actions array
  // const result = await db.query('SELECT * FROM games WHERE id = $1', [gameId]);
  // const game = result.rows[0];
  // return {
  //   actions: game.log,  // log contains the actions array
  //   variant: game.variant,
  //   seed: game.seed,
  //   // ... construct other Hand properties from game metadata
  // };
  return null;
}

/**
 * Mock database read for player balances
 * In production, this would query the players table for current chip balances
 */
export function loadPlayerBalances(tableId: string, playerIds: string[]): Map<string, number> {
  // TODO: Load actual player balances from database
  // const query = `
  //   SELECT player_id, chip_balance
  //   FROM player_balances
  //   WHERE table_id = $1 AND player_id = ANY($2)
  // `;
  // const result = await db.query(query, [tableId, playerIds]);

  // Mock implementation: return a Map of player -> balance
  const balances = new Map<string, number>();

  // In production, this would be populated from DB query results
  // For now, return empty map to indicate no DB data available
  return balances;
}

/**
 * Validates that starting stacks match database balances after hand transition
 * This ensures consistency between game state and persistent storage
 */
export function validateStacksWithDatabase(hand: Engine.Hand): void {
  // Skip validation if no venue IDs (can't map to DB records)
  if (!hand._venueIds || !hand.table) {
    return;
  }

  // Load player balances from database
  const dbBalances = loadPlayerBalances(hand.table, hand._venueIds);

  // If we have DB data, compare with hand starting stacks
  if (dbBalances.size > 0) {
    const discrepancies: string[] = [];

    hand.players.forEach((playerName, index) => {
      const venueId = hand._venueIds![index];
      const handStack = hand.startingStacks[index];
      const dbBalance = dbBalances.get(venueId);

      if (dbBalance !== undefined && dbBalance !== handStack) {
        discrepancies.push(
          `Player ${playerName} (${venueId}): Hand stack=${handStack}, DB balance=${dbBalance}`
        );
      }
    });

    if (discrepancies.length > 0) {
      const errorMessage = `Stack/Balance discrepancies detected after hand transition:\n${discrepancies.join('\n')}`;
      throw new Error(errorMessage);
    }
  }
}

export function savePlayerStats(hand: Engine.Hand): void {
  const stats = Engine.Stats(Engine.Game(hand));
  //await db.query('UPDATE games SET stats = $1 WHERE id = $2', [stats, hand.gameId]);
}

export function saveHand(hand: Engine.Hand): void {
  // TODO: Save the Hand to database and update timeout
  // The 'log' JSONB field stores the actions array
  // const game = Engine.Game(hand);
  //if (!Engine.Hand.isComplete(hand)) {
  // const timeoutAt = new Date(Date.now() + game.timeLimit * 1000);
  // await db.query('UPDATE games SET log = $1, timeout_at = $2 WHERE id = $3', [hand.actions, timeoutAt, hand.gameId]);
  //}
}

/**
 * Writes the updated player balance to the database
 * This is called after calculating profit/loss from a completed hand
 * @param playerName - The player's name
 * @param venueId - The player's venue ID for database lookup
 * @param newBalance - The player's new balance to save
 */
export function updatePlayerBalance(playerName: string, venueId: string, newBalance: number): void {
  // Write the new balance to the database
  // TODO: Replace with actual database update
  // const query = `
  //   UPDATE player_accounts
  //   SET balance = $1, last_updated = NOW()
  //   WHERE venue_id = $2
  // `;
  // await db.query(query, [newBalance, venueId]);

  console.log(`DB: Updated ${playerName} (${venueId}) balance to ${newBalance}`);
}

// ============================================================
// Session and Communication (Stubs)
// ============================================================

/**
 * Gets the current balance for a player from their session
 * In production, this would access req.user.session.buyIn
 * @param playerName - The player's name
 * @returns The player's current balance from session
 */
export function getSessionBalance(playerName: string): number {
  // TODO: In production, access the actual session for this player
  // This would typically come from req.user.session.buyIn
  // For different players, we'd need to access their respective sessions
  // Example: sessions.get(playerName)?.buyIn || 0

  // Mock implementation - return a default buyIn
  return 1000; // This would be req.user.session.buyIn
}

export function authorizeRequest(req: any, hand: Engine.Hand): void {
  // In a real implementation, this would check JWT, session, etc.
  // For our scaffold, we do nothing, effectively allowing all requests.
}

export function broadcastToPlayers(hand: Engine.Hand): void {
  // Send updated Hand state to all players with event type
  hand.players.forEach((playerName, playerIndex) => {
    // Create Hand state for specified player perspective
    const playerHand = Engine.Hand.personalize(hand, playerIndex);
    // Hand state can be serialized to JSON if needed
    //const serializedHand = Engine.Hand.serialize(playerPerspective, 'json');

    // TODO: Replace with actual websocket implementation
    // websocket.send(playerName, { event: eventType, hand: playerHand });
    //const playerId = Engine.Hand.getPlayerId(hand, playerName);
    // sendHandState(playerHand, playerId, eventType);
    console.log(`Broadcasting to ${playerName}:`, playerHand);
  });
}

// ============================================================
// Background Processes (Stubs)
// ============================================================

/**
 * Check for expired game timeouts and apply fold actions
 * This function should be called periodically (e.g., every second)
 *
 * This demonstrates how to handle timeouts in a background process:
 * - Finds games with expired timeouts
 * - Advances them (which auto-folds timed-out players)
 * - Handles completion and transitions just like the main endpoint
 */
export async function checkGameTimeouts(): Promise<void> {
  // Note: 'db' is a placeholder for your database connection
  // Replace with your actual database client (PostgreSQL, MySQL, etc.)
  // @ts-expect-error
  const expiredGames = await db.query(
    'SELECT id FROM games WHERE timeout_at < NOW() AND timeout_at IS NOT NULL'
  );

  for (const row of expiredGames.rows) {
    // Load the current game state
    let hand = loadGameHand(row.venue, row.id);
    if (!hand) continue;

    // This function needs to be passed in or imported to avoid circular dependency
    // For now, we assume it's available in the scope where this is called.
    // advanceHand(hand);
    console.log(`Processing timeout for game ${row.venue}/${row.id}`);
  }
}
