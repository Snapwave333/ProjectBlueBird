# Poker Integration Plan

This document outlines the development and integration plan for the new poker game, breaking down the work into three main milestones.

---

## Architectural Philosophy: A Game-Agnostic Foundation

A key principle of this integration is to build a generic, reusable backend infrastructure that can support not only poker but also future games with minimal additional engineering.

- **Generic Components:** The core backend mechanisms — `GameEngineLogs`, `GameEngineTables`, `BusinessSessions`, and the logic for seating, timeouts, and state advancement — are intentionally designed to be game-agnostic. They handle the "what" (a game state exists, a session is active) but not the "how" (the specific rules of the game).
- **Future-Proofing:** This approach means that integrating a new game in the future (e.g., Dominoes) will primarily involve creating a new game engine logic module and a new frontend UI. The complex, foundational work of session management, table lifecycle, and state persistence will already be in place and reusable.
- **Poker-Specific Components:** The only parts of this plan that are specific to poker are:
  1.  The `poker-engine` logic module itself.
  2.  The frontend **Core Game UI**.
  3.  The schema of the `GameEnginePokerStats` table, which is tailored to poker-specific metrics.

---

## Milestone 0: Infrastructure & DevOps Foundation

**Goal:** Establish a robust, containerized, and observable environment to support development, testing, and deployment.
**Owner:** Alex

### Prerequisites (Casino Team Responsibility)

1.  **Platform Refactoring for Scalability (Owner: Mikhail):**
    - **Action:** Prepare the existing platform for containerization and clustering.
    - **Logic:**
      - Extract the socket server into a standalone, container-ready service.
      - Refactor the backend to remove all single-process caching mechanisms, enabling stateless horizontal scaling.
2.  **Business Session Finalization:**
    - **Action:** Finalize the `BusinessSession` model based on the provided stub.
    - **Logic:** Define session start/end triggers and integrate buy-in mechanics.

### Tasks (Alex's Responsibility)

1.  **Full Project Containerization**
    - **Action:** Create Dockerfiles and a Docker Compose setup for the entire application stack.
    - **Scope:** This includes the backend, frontend, socket server, test runner, and database services.

2.  **CI/CD Pipeline Enhancement**
    - **Action:** Update the GitHub Actions workflow to run the full `docker-compose` stack.
    - **Goal:** To ensure integration tests are executed in a production-like environment.

3.  **Backend Instrumentation & Monitoring**
    - **Action:** Integrate an instrumentation library (e.g., OpenTelemetry) into all Node.js services.
    - **Goal:** To provide observability into application performance, database queries, and overall system health.

4.  **Node.js Server Clustering**
    - **Action:** Implement Node.js clustering for the main backend service.
    - **Goal:** To leverage multiple CPU cores, increasing throughput and resilience. (Depends on platform refactoring).

---

## Milestone 1: Core Multiplayer Gameplay

**Goal:** Enable real users to play a complete game of multiplayer poker.

### Backend Development

1.  **Core Game Advancement Logic**
    - **Action:** Abstract the core game state advancement logic into a dedicated, reusable component/function.
    - **Responsibilities:** This component will be the single source of truth for processing any game action. Its responsibilities include:
      - Taking a game state and a player action as input.
      - Using the poker engine to validate the action and compute the next state.
      - Saving the new state to the database via `UPSERT`.
      - Calculating and storing the timeout for the next player.
      - Triggering the dispatch of masked state notifications to all players.

2.  **Game State Management Endpoint**
    - **Action:** Create an endpoint that accepts player actions (e.g., bet, check, fold).
    - **Logic:** This endpoint acts as a thin wrapper. It receives a player's action notation, loads the current game state, and then invokes the **Core Game Advancement Logic** component to process the action.

3.  **Player Timeout Handling**
    - **Action:** Implement a background process to handle players who do not act in time.
    - **Logic:**
      - A background polling mechanism within the Node.js process (e.g., using `setInterval`) runs every second to query for games with an expired timeout.
      - For each expired game, the system generates an "auto-fold" action and invokes the **Core Game Advancement Logic** component to process it.

4.  **Seating and Table Management**
    - **Action:** Create an endpoint for players to join a game.
    - **Logic:**
      - A player requests to join a game at a specific limit, optionally providing a specific `tableId`.
      - The system searches for a table that matches the criteria (limit and optional `tableId`) and has open seats. An open seat is determined by checking that the number of active `BusinessSessions` associated with the table is less than its `max_seats`.
      - **If a suitable table is found:** The player is seated, and a new `BusinessSession` is created for them, linking them to the table. They will be dealt in starting from the next hand.
      - **If no table is found (and no `tableId` was specified):** A new table is created, and the player is seated as the first player.
    - **Table Lifecycle:**
      - Tables are persistent records in the database.
      - When a table becomes empty (or contains only bots) for a set period (e.g., 15 minutes), it is marked as "closed," not deleted.

5.  **New Hand Logic & Winnings Distribution**
    - **Action:** Automate the start of a new hand and handle the distribution of winnings from the concluded hand.
    - **Logic:**
      - When the poker engine determines a hand is over, the backend notifies all players of the result.
      - A database transaction then atomically redistributes winnings. **Note:** The exact implementation of this transaction is dependent on the final `BusinessSession` design from the Casino team. It may involve updating the `stack` value directly within active sessions or calling a separate, centralized transaction service.
      - After a short, fixed delay (e.g., 3 seconds), a new hand is automatically dealt, and players are notified.

### Frontend Development

1.  **Game Limit Selection UI**
    - **Action:** Adapt the existing game limit UI for poker.
    - **Logic:**
      - Create a new, custom UI template to display poker stakes (e.g., "1/2", "5/10") instead of the generic limit format.
      - Populate the UI with poker-specific limit records created via a database migration.

2.  **Player Buy-in Flow**
    - **Action:** Implement the player buy-in, which is managed by the Business Session.
    - **Logic:**
      - **Default Behavior:** Initially, when a `BusinessSession` is created for a poker game, it will automatically buy-in the player for their entire available balance.
      - **Future UI:** A proper UI (e.g., a modal) for selecting a custom buy-in amount will be implemented later. This UI will then update the `buy_in` field in the `BusinessSession`.

3.  **Client-Side Seating Request**
    - **Action:** Immediately after the `BusinessSession` is created, the client-side logic initiates the seating process.
    - **Logic:** The client calls the backend's "Seating and Table Management" endpoint. It then waits for a successful response before attempting to render the game UI, ensuring the player is properly seated at a table.

4.  **Core Game UI**
    - **Owner:** Sargis.
    - **Action:** Build the main poker table interface where gameplay occurs.
    - **Architecture:** The UI will act as a view layer for the `poker-engine`. It will receive a complete, masked game state from the server and render it. Its primary responsibilities are visual representation and capturing user input (e.g., clicks on "bet" or "fold") to send the appropriate action notation to the backend. It will not contain complex game logic, as that is handled entirely by the engine on the server side.

### Session Management

- **Action:** Design and implement a new "Business Session" model to track long-lived player activity.
- **Ownership & Finalization:** The `BusinessSession` model has been implemented as a minimal, non-prescriptive stub to support the poker table system. The final implementation is the responsibility of the **Casino team**. We request that you take this stub as a basis for extension. Key areas for finalization include defining the precise start/end triggers for a session and integrating the buy-in mechanics. The stub was designed to be fully adaptable to your final architectural decisions.
- **Logic:**
  - A session starts when a player joins a table and ends when they leave.
  - This session will track the player, the table they are at (`table_id`), their `buy_in`, and other game-specific metadata in a `JSONB` column.
  - This is critical for tracking active players, managing table capacity, and calculating Jade billing.
  - **Note:** This is a new, separate concept from the existing session implementation.

---

## Milestone 2: Bot Integration

**Goal:** Allow AI bots to play against human players to ensure tables are always active.

1.  **Bot API & Webhooks**
    - **Action:** Create the necessary communication layer between the main backend and the bot service.
    - **Webhook 1: Notify on Game State Change:** Whenever any player (human or bot) makes a move, send the new game state to the bot service for any bots at that table.
    - **Webhook 2: Request Bot to Join Table:** When a human needs opponents, send a request to the bot service to have one or more bots join a specific table.
    - **Endpoint for Bot Actions:** The bot service will call the same game update endpoint used by human players to submit its moves.

2.  **Authentication**
    - **Action:** Implement a secure method for the bot service to authenticate.
    - **Logic:** The game update endpoint will be modified to accept a secret API key in the request header, bypassing the standard user session authentication.

3.  **Bot User Profiles**
    - **Action:** Ensure bots are represented as regular users within the system.
    - **Logic:**
      - A pool of bot user profiles (with AI-generated names and avatars) will be pre-generated and stored in the user database.
      - When a bot joins a game, it is associated with one of these user profiles.
    - **Initial Scope:** For the initial implementation, bots will only play in the public Lobby to simplify logic around private clubs.

---

## Milestone 3: Statistics and Analytics

**Goal:** Capture, store, and aggregate detailed game statistics for future analysis and player-facing features.

1.  **Raw Stat Collection (Phase 1)**
    - **Action:** Save all statistics generated by the poker engine.
    - **Logic:**
      - Create a new database table (`GameEnginePokerStats`).
      - On every hand, save the raw JSON stats output from the engine into this table.
    - **Goal:** This ensures no data is lost, even before advanced aggregation is in place.

2.  **Data Aggregation with TimescaleDB (Phase 2)**
    - **Action:** Integrate TimescaleDB for efficient time-series data aggregation.
    - **Logic:**
      - Update the project's Docker configuration to use the TimescaleDB image instead of standard PostgreSQL.
      - Create a one-time SQL script to initialize TimescaleDB features, including creating hypertables and continuous aggregates on the stats table.

3.  **Statistics UI (Optional Stretch Goal)**
    - **Action:** Create a player-facing widget to display key stats.
    - **Depends on:** Design from Alexey. This is a "nice-to-have" and can be deferred.

---

## Database Schema Design

- **`GameEngineLogs`**: Stores the current state of each active game. (Mutable)
  - `id`
  - `table_id` (FK to `GameEngineTables`)
  - `limit_id` (FK)
  - `club_id` (FK)
  - `game_id` (FK)
  - `hand` (JSONB) - The full game state from the engine.
- **`GameEngineTables`**: Stores metadata about each poker table. (Persistent)
  - `id`
  - `limit_id` (FK)
  - `club_id` (FK)
  - `game_id` (FK)
  - `max_seats` (Integer)
  - `closed_at` (if closed)
- **`BusinessSessions`**: A new, generic table for tracking long-lived user game sessions.
  - `id`
  - `user_id` (FK)
  - `club_id` (FK)
  - `game_id` (FK)
  - `start_time`, `end_time`
  - `table_id` (FK to `GameEngineTables`, nullable) - The specific table the player is at.
  - `stack` (Numeric) - The amount the player bought in for.
  - `settings` (JSONB) - For any other game-specific, dynamic data.
  - `jade_burn_rate_per_hour` (Numeric) - The number of Jades this session consumes per hour. This rate can be different for bots vs. humans and may be affected by club tier.
- **`GameEnginePokerStats`**: Stores raw, immutable stats for each hand.
  - Will be defined by the structure provided by Yaroslav.
